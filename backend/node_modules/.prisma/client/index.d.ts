
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model Mask
 * 
 */
export type Mask = $Result.DefaultSelection<Prisma.$MaskPayload>
/**
 * Model PlayerMask
 * 
 */
export type PlayerMask = $Result.DefaultSelection<Prisma.$PlayerMaskPayload>
/**
 * Model NPC
 * 
 */
export type NPC = $Result.DefaultSelection<Prisma.$NPCPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model PlayerItem
 * 
 */
export type PlayerItem = $Result.DefaultSelection<Prisma.$PlayerItemPayload>
/**
 * Model Minigame
 * 
 */
export type Minigame = $Result.DefaultSelection<Prisma.$MinigamePayload>
/**
 * Model PlayerMinigame
 * 
 */
export type PlayerMinigame = $Result.DefaultSelection<Prisma.$PlayerMinigamePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model PlayerEvent
 * 
 */
export type PlayerEvent = $Result.DefaultSelection<Prisma.$PlayerEventPayload>
/**
 * Model Action
 * 
 */
export type Action = $Result.DefaultSelection<Prisma.$ActionPayload>
/**
 * Model PlayerRelationship
 * 
 */
export type PlayerRelationship = $Result.DefaultSelection<Prisma.$PlayerRelationshipPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Players
 * const players = await prisma.player.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Players
   * const players = await prisma.player.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs>;

  /**
   * `prisma.mask`: Exposes CRUD operations for the **Mask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Masks
    * const masks = await prisma.mask.findMany()
    * ```
    */
  get mask(): Prisma.MaskDelegate<ExtArgs>;

  /**
   * `prisma.playerMask`: Exposes CRUD operations for the **PlayerMask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerMasks
    * const playerMasks = await prisma.playerMask.findMany()
    * ```
    */
  get playerMask(): Prisma.PlayerMaskDelegate<ExtArgs>;

  /**
   * `prisma.nPC`: Exposes CRUD operations for the **NPC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NPCS
    * const nPCS = await prisma.nPC.findMany()
    * ```
    */
  get nPC(): Prisma.NPCDelegate<ExtArgs>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.playerItem`: Exposes CRUD operations for the **PlayerItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerItems
    * const playerItems = await prisma.playerItem.findMany()
    * ```
    */
  get playerItem(): Prisma.PlayerItemDelegate<ExtArgs>;

  /**
   * `prisma.minigame`: Exposes CRUD operations for the **Minigame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Minigames
    * const minigames = await prisma.minigame.findMany()
    * ```
    */
  get minigame(): Prisma.MinigameDelegate<ExtArgs>;

  /**
   * `prisma.playerMinigame`: Exposes CRUD operations for the **PlayerMinigame** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerMinigames
    * const playerMinigames = await prisma.playerMinigame.findMany()
    * ```
    */
  get playerMinigame(): Prisma.PlayerMinigameDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.playerEvent`: Exposes CRUD operations for the **PlayerEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerEvents
    * const playerEvents = await prisma.playerEvent.findMany()
    * ```
    */
  get playerEvent(): Prisma.PlayerEventDelegate<ExtArgs>;

  /**
   * `prisma.action`: Exposes CRUD operations for the **Action** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actions
    * const actions = await prisma.action.findMany()
    * ```
    */
  get action(): Prisma.ActionDelegate<ExtArgs>;

  /**
   * `prisma.playerRelationship`: Exposes CRUD operations for the **PlayerRelationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlayerRelationships
    * const playerRelationships = await prisma.playerRelationship.findMany()
    * ```
    */
  get playerRelationship(): Prisma.PlayerRelationshipDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Player: 'Player',
    Mask: 'Mask',
    PlayerMask: 'PlayerMask',
    NPC: 'NPC',
    Zone: 'Zone',
    Item: 'Item',
    PlayerItem: 'PlayerItem',
    Minigame: 'Minigame',
    PlayerMinigame: 'PlayerMinigame',
    Event: 'Event',
    PlayerEvent: 'PlayerEvent',
    Action: 'Action',
    PlayerRelationship: 'PlayerRelationship'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "player" | "mask" | "playerMask" | "nPC" | "zone" | "item" | "playerItem" | "minigame" | "playerMinigame" | "event" | "playerEvent" | "action" | "playerRelationship"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      Mask: {
        payload: Prisma.$MaskPayload<ExtArgs>
        fields: Prisma.MaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload>
          }
          findFirst: {
            args: Prisma.MaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload>
          }
          findMany: {
            args: Prisma.MaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload>[]
          }
          create: {
            args: Prisma.MaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload>
          }
          createMany: {
            args: Prisma.MaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload>[]
          }
          delete: {
            args: Prisma.MaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload>
          }
          update: {
            args: Prisma.MaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload>
          }
          deleteMany: {
            args: Prisma.MaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaskPayload>
          }
          aggregate: {
            args: Prisma.MaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMask>
          }
          groupBy: {
            args: Prisma.MaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaskCountArgs<ExtArgs>
            result: $Utils.Optional<MaskCountAggregateOutputType> | number
          }
        }
      }
      PlayerMask: {
        payload: Prisma.$PlayerMaskPayload<ExtArgs>
        fields: Prisma.PlayerMaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerMaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerMaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload>
          }
          findFirst: {
            args: Prisma.PlayerMaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerMaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload>
          }
          findMany: {
            args: Prisma.PlayerMaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload>[]
          }
          create: {
            args: Prisma.PlayerMaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload>
          }
          createMany: {
            args: Prisma.PlayerMaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerMaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload>[]
          }
          delete: {
            args: Prisma.PlayerMaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload>
          }
          update: {
            args: Prisma.PlayerMaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload>
          }
          deleteMany: {
            args: Prisma.PlayerMaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerMaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerMaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMaskPayload>
          }
          aggregate: {
            args: Prisma.PlayerMaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerMask>
          }
          groupBy: {
            args: Prisma.PlayerMaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerMaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerMaskCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerMaskCountAggregateOutputType> | number
          }
        }
      }
      NPC: {
        payload: Prisma.$NPCPayload<ExtArgs>
        fields: Prisma.NPCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NPCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NPCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          findFirst: {
            args: Prisma.NPCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NPCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          findMany: {
            args: Prisma.NPCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          create: {
            args: Prisma.NPCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          createMany: {
            args: Prisma.NPCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NPCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>[]
          }
          delete: {
            args: Prisma.NPCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          update: {
            args: Prisma.NPCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          deleteMany: {
            args: Prisma.NPCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NPCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NPCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NPCPayload>
          }
          aggregate: {
            args: Prisma.NPCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNPC>
          }
          groupBy: {
            args: Prisma.NPCGroupByArgs<ExtArgs>
            result: $Utils.Optional<NPCGroupByOutputType>[]
          }
          count: {
            args: Prisma.NPCCountArgs<ExtArgs>
            result: $Utils.Optional<NPCCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      PlayerItem: {
        payload: Prisma.$PlayerItemPayload<ExtArgs>
        fields: Prisma.PlayerItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload>
          }
          findFirst: {
            args: Prisma.PlayerItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload>
          }
          findMany: {
            args: Prisma.PlayerItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload>[]
          }
          create: {
            args: Prisma.PlayerItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload>
          }
          createMany: {
            args: Prisma.PlayerItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload>[]
          }
          delete: {
            args: Prisma.PlayerItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload>
          }
          update: {
            args: Prisma.PlayerItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload>
          }
          deleteMany: {
            args: Prisma.PlayerItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerItemPayload>
          }
          aggregate: {
            args: Prisma.PlayerItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerItem>
          }
          groupBy: {
            args: Prisma.PlayerItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerItemCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerItemCountAggregateOutputType> | number
          }
        }
      }
      Minigame: {
        payload: Prisma.$MinigamePayload<ExtArgs>
        fields: Prisma.MinigameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MinigameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MinigameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload>
          }
          findFirst: {
            args: Prisma.MinigameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MinigameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload>
          }
          findMany: {
            args: Prisma.MinigameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload>[]
          }
          create: {
            args: Prisma.MinigameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload>
          }
          createMany: {
            args: Prisma.MinigameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MinigameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload>[]
          }
          delete: {
            args: Prisma.MinigameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload>
          }
          update: {
            args: Prisma.MinigameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload>
          }
          deleteMany: {
            args: Prisma.MinigameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MinigameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MinigameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MinigamePayload>
          }
          aggregate: {
            args: Prisma.MinigameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMinigame>
          }
          groupBy: {
            args: Prisma.MinigameGroupByArgs<ExtArgs>
            result: $Utils.Optional<MinigameGroupByOutputType>[]
          }
          count: {
            args: Prisma.MinigameCountArgs<ExtArgs>
            result: $Utils.Optional<MinigameCountAggregateOutputType> | number
          }
        }
      }
      PlayerMinigame: {
        payload: Prisma.$PlayerMinigamePayload<ExtArgs>
        fields: Prisma.PlayerMinigameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerMinigameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerMinigameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload>
          }
          findFirst: {
            args: Prisma.PlayerMinigameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerMinigameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload>
          }
          findMany: {
            args: Prisma.PlayerMinigameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload>[]
          }
          create: {
            args: Prisma.PlayerMinigameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload>
          }
          createMany: {
            args: Prisma.PlayerMinigameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerMinigameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload>[]
          }
          delete: {
            args: Prisma.PlayerMinigameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload>
          }
          update: {
            args: Prisma.PlayerMinigameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload>
          }
          deleteMany: {
            args: Prisma.PlayerMinigameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerMinigameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerMinigameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerMinigamePayload>
          }
          aggregate: {
            args: Prisma.PlayerMinigameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerMinigame>
          }
          groupBy: {
            args: Prisma.PlayerMinigameGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerMinigameGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerMinigameCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerMinigameCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      PlayerEvent: {
        payload: Prisma.$PlayerEventPayload<ExtArgs>
        fields: Prisma.PlayerEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload>
          }
          findFirst: {
            args: Prisma.PlayerEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload>
          }
          findMany: {
            args: Prisma.PlayerEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload>[]
          }
          create: {
            args: Prisma.PlayerEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload>
          }
          createMany: {
            args: Prisma.PlayerEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload>[]
          }
          delete: {
            args: Prisma.PlayerEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload>
          }
          update: {
            args: Prisma.PlayerEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload>
          }
          deleteMany: {
            args: Prisma.PlayerEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerEventPayload>
          }
          aggregate: {
            args: Prisma.PlayerEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerEvent>
          }
          groupBy: {
            args: Prisma.PlayerEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerEventCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerEventCountAggregateOutputType> | number
          }
        }
      }
      Action: {
        payload: Prisma.$ActionPayload<ExtArgs>
        fields: Prisma.ActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findFirst: {
            args: Prisma.ActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          findMany: {
            args: Prisma.ActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          create: {
            args: Prisma.ActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          createMany: {
            args: Prisma.ActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>[]
          }
          delete: {
            args: Prisma.ActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          update: {
            args: Prisma.ActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          deleteMany: {
            args: Prisma.ActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionPayload>
          }
          aggregate: {
            args: Prisma.ActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAction>
          }
          groupBy: {
            args: Prisma.ActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionCountArgs<ExtArgs>
            result: $Utils.Optional<ActionCountAggregateOutputType> | number
          }
        }
      }
      PlayerRelationship: {
        payload: Prisma.$PlayerRelationshipPayload<ExtArgs>
        fields: Prisma.PlayerRelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerRelationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerRelationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload>
          }
          findFirst: {
            args: Prisma.PlayerRelationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerRelationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload>
          }
          findMany: {
            args: Prisma.PlayerRelationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload>[]
          }
          create: {
            args: Prisma.PlayerRelationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload>
          }
          createMany: {
            args: Prisma.PlayerRelationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerRelationshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload>[]
          }
          delete: {
            args: Prisma.PlayerRelationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload>
          }
          update: {
            args: Prisma.PlayerRelationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload>
          }
          deleteMany: {
            args: Prisma.PlayerRelationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerRelationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlayerRelationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerRelationshipPayload>
          }
          aggregate: {
            args: Prisma.PlayerRelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayerRelationship>
          }
          groupBy: {
            args: Prisma.PlayerRelationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerRelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerRelationshipCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerRelationshipCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    masksOwned: number
    relationships: number
    inventory: number
    minigameProgress: number
    eventsCompleted: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    masksOwned?: boolean | PlayerCountOutputTypeCountMasksOwnedArgs
    relationships?: boolean | PlayerCountOutputTypeCountRelationshipsArgs
    inventory?: boolean | PlayerCountOutputTypeCountInventoryArgs
    minigameProgress?: boolean | PlayerCountOutputTypeCountMinigameProgressArgs
    eventsCompleted?: boolean | PlayerCountOutputTypeCountEventsCompletedArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMasksOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMaskWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerRelationshipWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountInventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerItemWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMinigameProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMinigameWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountEventsCompletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEventWhereInput
  }


  /**
   * Count Type MaskCountOutputType
   */

  export type MaskCountOutputType = {
    players: number
    currentPlayers: number
  }

  export type MaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | MaskCountOutputTypeCountPlayersArgs
    currentPlayers?: boolean | MaskCountOutputTypeCountCurrentPlayersArgs
  }

  // Custom InputTypes
  /**
   * MaskCountOutputType without action
   */
  export type MaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaskCountOutputType
     */
    select?: MaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaskCountOutputType without action
   */
  export type MaskCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMaskWhereInput
  }

  /**
   * MaskCountOutputType without action
   */
  export type MaskCountOutputTypeCountCurrentPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }


  /**
   * Count Type NPCCountOutputType
   */

  export type NPCCountOutputType = {
    playerRelationships: number
  }

  export type NPCCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerRelationships?: boolean | NPCCountOutputTypeCountPlayerRelationshipsArgs
  }

  // Custom InputTypes
  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPCCountOutputType
     */
    select?: NPCCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NPCCountOutputType without action
   */
  export type NPCCountOutputTypeCountPlayerRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerRelationshipWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    npcs: number
    players: number
    events: number
    actions: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npcs?: boolean | ZoneCountOutputTypeCountNpcsArgs
    players?: boolean | ZoneCountOutputTypeCountPlayersArgs
    events?: boolean | ZoneCountOutputTypeCountEventsArgs
    actions?: boolean | ZoneCountOutputTypeCountActionsArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountNpcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    players: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | ItemCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerItemWhereInput
  }


  /**
   * Count Type MinigameCountOutputType
   */

  export type MinigameCountOutputType = {
    playerProgress: number
  }

  export type MinigameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerProgress?: boolean | MinigameCountOutputTypeCountPlayerProgressArgs
  }

  // Custom InputTypes
  /**
   * MinigameCountOutputType without action
   */
  export type MinigameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MinigameCountOutputType
     */
    select?: MinigameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MinigameCountOutputType without action
   */
  export type MinigameCountOutputTypeCountPlayerProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMinigameWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    players: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | EventCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerAvgAggregateOutputType = {
    grade: number | null
    energy: number | null
    reputation: number | null
  }

  export type PlayerSumAggregateOutputType = {
    grade: number | null
    energy: number | null
    reputation: number | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    username: string | null
    avatar: string | null
    grade: number | null
    className: string | null
    currentMaskId: string | null
    energy: number | null
    mood: string | null
    time: string | null
    reputation: number | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    username: string | null
    avatar: string | null
    grade: number | null
    className: string | null
    currentMaskId: string | null
    energy: number | null
    mood: string | null
    time: string | null
    reputation: number | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    username: number
    avatar: number
    grade: number
    className: number
    currentMaskId: number
    energy: number
    mood: number
    time: number
    reputation: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlayerAvgAggregateInputType = {
    grade?: true
    energy?: true
    reputation?: true
  }

  export type PlayerSumAggregateInputType = {
    grade?: true
    energy?: true
    reputation?: true
  }

  export type PlayerMinAggregateInputType = {
    id?: true
    username?: true
    avatar?: true
    grade?: true
    className?: true
    currentMaskId?: true
    energy?: true
    mood?: true
    time?: true
    reputation?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    username?: true
    avatar?: true
    grade?: true
    className?: true
    currentMaskId?: true
    energy?: true
    mood?: true
    time?: true
    reputation?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    username?: true
    avatar?: true
    grade?: true
    className?: true
    currentMaskId?: true
    energy?: true
    mood?: true
    time?: true
    reputation?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _avg?: PlayerAvgAggregateInputType
    _sum?: PlayerSumAggregateInputType
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId: string | null
    energy: number
    mood: string
    time: string
    reputation: number
    zoneId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlayerCountAggregateOutputType | null
    _avg: PlayerAvgAggregateOutputType | null
    _sum: PlayerSumAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    avatar?: boolean
    grade?: boolean
    className?: boolean
    currentMaskId?: boolean
    energy?: boolean
    mood?: boolean
    time?: boolean
    reputation?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMask?: boolean | Player$currentMaskArgs<ExtArgs>
    masksOwned?: boolean | Player$masksOwnedArgs<ExtArgs>
    relationships?: boolean | Player$relationshipsArgs<ExtArgs>
    inventory?: boolean | Player$inventoryArgs<ExtArgs>
    minigameProgress?: boolean | Player$minigameProgressArgs<ExtArgs>
    eventsCompleted?: boolean | Player$eventsCompletedArgs<ExtArgs>
    location?: boolean | Player$locationArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    avatar?: boolean
    grade?: boolean
    className?: boolean
    currentMaskId?: boolean
    energy?: boolean
    mood?: boolean
    time?: boolean
    reputation?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    currentMask?: boolean | Player$currentMaskArgs<ExtArgs>
    location?: boolean | Player$locationArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    username?: boolean
    avatar?: boolean
    grade?: boolean
    className?: boolean
    currentMaskId?: boolean
    energy?: boolean
    mood?: boolean
    time?: boolean
    reputation?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentMask?: boolean | Player$currentMaskArgs<ExtArgs>
    masksOwned?: boolean | Player$masksOwnedArgs<ExtArgs>
    relationships?: boolean | Player$relationshipsArgs<ExtArgs>
    inventory?: boolean | Player$inventoryArgs<ExtArgs>
    minigameProgress?: boolean | Player$minigameProgressArgs<ExtArgs>
    eventsCompleted?: boolean | Player$eventsCompletedArgs<ExtArgs>
    location?: boolean | Player$locationArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currentMask?: boolean | Player$currentMaskArgs<ExtArgs>
    location?: boolean | Player$locationArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      currentMask: Prisma.$MaskPayload<ExtArgs> | null
      masksOwned: Prisma.$PlayerMaskPayload<ExtArgs>[]
      relationships: Prisma.$PlayerRelationshipPayload<ExtArgs>[]
      inventory: Prisma.$PlayerItemPayload<ExtArgs>[]
      minigameProgress: Prisma.$PlayerMinigamePayload<ExtArgs>[]
      eventsCompleted: Prisma.$PlayerEventPayload<ExtArgs>[]
      location: Prisma.$ZonePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      avatar: string
      grade: number
      className: string
      currentMaskId: string | null
      energy: number
      mood: string
      time: string
      reputation: number
      zoneId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currentMask<T extends Player$currentMaskArgs<ExtArgs> = {}>(args?: Subset<T, Player$currentMaskArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    masksOwned<T extends Player$masksOwnedArgs<ExtArgs> = {}>(args?: Subset<T, Player$masksOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "findMany"> | Null>
    relationships<T extends Player$relationshipsArgs<ExtArgs> = {}>(args?: Subset<T, Player$relationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "findMany"> | Null>
    inventory<T extends Player$inventoryArgs<ExtArgs> = {}>(args?: Subset<T, Player$inventoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "findMany"> | Null>
    minigameProgress<T extends Player$minigameProgressArgs<ExtArgs> = {}>(args?: Subset<T, Player$minigameProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "findMany"> | Null>
    eventsCompleted<T extends Player$eventsCompletedArgs<ExtArgs> = {}>(args?: Subset<T, Player$eventsCompletedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "findMany"> | Null>
    location<T extends Player$locationArgs<ExtArgs> = {}>(args?: Subset<T, Player$locationArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */ 
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'String'>
    readonly username: FieldRef<"Player", 'String'>
    readonly avatar: FieldRef<"Player", 'String'>
    readonly grade: FieldRef<"Player", 'Int'>
    readonly className: FieldRef<"Player", 'String'>
    readonly currentMaskId: FieldRef<"Player", 'String'>
    readonly energy: FieldRef<"Player", 'Int'>
    readonly mood: FieldRef<"Player", 'String'>
    readonly time: FieldRef<"Player", 'String'>
    readonly reputation: FieldRef<"Player", 'Int'>
    readonly zoneId: FieldRef<"Player", 'String'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly updatedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
  }

  /**
   * Player.currentMask
   */
  export type Player$currentMaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    where?: MaskWhereInput
  }

  /**
   * Player.masksOwned
   */
  export type Player$masksOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    where?: PlayerMaskWhereInput
    orderBy?: PlayerMaskOrderByWithRelationInput | PlayerMaskOrderByWithRelationInput[]
    cursor?: PlayerMaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerMaskScalarFieldEnum | PlayerMaskScalarFieldEnum[]
  }

  /**
   * Player.relationships
   */
  export type Player$relationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    where?: PlayerRelationshipWhereInput
    orderBy?: PlayerRelationshipOrderByWithRelationInput | PlayerRelationshipOrderByWithRelationInput[]
    cursor?: PlayerRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerRelationshipScalarFieldEnum | PlayerRelationshipScalarFieldEnum[]
  }

  /**
   * Player.inventory
   */
  export type Player$inventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    where?: PlayerItemWhereInput
    orderBy?: PlayerItemOrderByWithRelationInput | PlayerItemOrderByWithRelationInput[]
    cursor?: PlayerItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerItemScalarFieldEnum | PlayerItemScalarFieldEnum[]
  }

  /**
   * Player.minigameProgress
   */
  export type Player$minigameProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    where?: PlayerMinigameWhereInput
    orderBy?: PlayerMinigameOrderByWithRelationInput | PlayerMinigameOrderByWithRelationInput[]
    cursor?: PlayerMinigameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerMinigameScalarFieldEnum | PlayerMinigameScalarFieldEnum[]
  }

  /**
   * Player.eventsCompleted
   */
  export type Player$eventsCompletedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    where?: PlayerEventWhereInput
    orderBy?: PlayerEventOrderByWithRelationInput | PlayerEventOrderByWithRelationInput[]
    cursor?: PlayerEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerEventScalarFieldEnum | PlayerEventScalarFieldEnum[]
  }

  /**
   * Player.location
   */
  export type Player$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model Mask
   */

  export type AggregateMask = {
    _count: MaskCountAggregateOutputType | null
    _avg: MaskAvgAggregateOutputType | null
    _sum: MaskSumAggregateOutputType | null
    _min: MaskMinAggregateOutputType | null
    _max: MaskMaxAggregateOutputType | null
  }

  export type MaskAvgAggregateOutputType = {
    corruption: number | null
  }

  export type MaskSumAggregateOutputType = {
    corruption: number | null
  }

  export type MaskMinAggregateOutputType = {
    id: string | null
    name: string | null
    alias: string | null
    description: string | null
    personality: string | null
    corruption: number | null
    image: string | null
    symbol: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaskMaxAggregateOutputType = {
    id: string | null
    name: string | null
    alias: string | null
    description: string | null
    personality: string | null
    corruption: number | null
    image: string | null
    symbol: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaskCountAggregateOutputType = {
    id: number
    name: number
    alias: number
    description: number
    personality: number
    corruption: number
    abilities: number
    dailyEffects: number
    corruptionTriggers: number
    unlockRequirements: number
    image: number
    symbol: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaskAvgAggregateInputType = {
    corruption?: true
  }

  export type MaskSumAggregateInputType = {
    corruption?: true
  }

  export type MaskMinAggregateInputType = {
    id?: true
    name?: true
    alias?: true
    description?: true
    personality?: true
    corruption?: true
    image?: true
    symbol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaskMaxAggregateInputType = {
    id?: true
    name?: true
    alias?: true
    description?: true
    personality?: true
    corruption?: true
    image?: true
    symbol?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaskCountAggregateInputType = {
    id?: true
    name?: true
    alias?: true
    description?: true
    personality?: true
    corruption?: true
    abilities?: true
    dailyEffects?: true
    corruptionTriggers?: true
    unlockRequirements?: true
    image?: true
    symbol?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mask to aggregate.
     */
    where?: MaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Masks to fetch.
     */
    orderBy?: MaskOrderByWithRelationInput | MaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Masks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Masks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Masks
    **/
    _count?: true | MaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaskMaxAggregateInputType
  }

  export type GetMaskAggregateType<T extends MaskAggregateArgs> = {
        [P in keyof T & keyof AggregateMask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMask[P]>
      : GetScalarType<T[P], AggregateMask[P]>
  }




  export type MaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaskWhereInput
    orderBy?: MaskOrderByWithAggregationInput | MaskOrderByWithAggregationInput[]
    by: MaskScalarFieldEnum[] | MaskScalarFieldEnum
    having?: MaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaskCountAggregateInputType | true
    _avg?: MaskAvgAggregateInputType
    _sum?: MaskSumAggregateInputType
    _min?: MaskMinAggregateInputType
    _max?: MaskMaxAggregateInputType
  }

  export type MaskGroupByOutputType = {
    id: string
    name: string
    alias: string
    description: string
    personality: string
    corruption: number
    abilities: JsonValue
    dailyEffects: JsonValue
    corruptionTriggers: string[]
    unlockRequirements: string[]
    image: string
    symbol: string
    createdAt: Date
    updatedAt: Date
    _count: MaskCountAggregateOutputType | null
    _avg: MaskAvgAggregateOutputType | null
    _sum: MaskSumAggregateOutputType | null
    _min: MaskMinAggregateOutputType | null
    _max: MaskMaxAggregateOutputType | null
  }

  type GetMaskGroupByPayload<T extends MaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaskGroupByOutputType[P]>
            : GetScalarType<T[P], MaskGroupByOutputType[P]>
        }
      >
    >


  export type MaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    alias?: boolean
    description?: boolean
    personality?: boolean
    corruption?: boolean
    abilities?: boolean
    dailyEffects?: boolean
    corruptionTriggers?: boolean
    unlockRequirements?: boolean
    image?: boolean
    symbol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    players?: boolean | Mask$playersArgs<ExtArgs>
    currentPlayers?: boolean | Mask$currentPlayersArgs<ExtArgs>
    _count?: boolean | MaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mask"]>

  export type MaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    alias?: boolean
    description?: boolean
    personality?: boolean
    corruption?: boolean
    abilities?: boolean
    dailyEffects?: boolean
    corruptionTriggers?: boolean
    unlockRequirements?: boolean
    image?: boolean
    symbol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["mask"]>

  export type MaskSelectScalar = {
    id?: boolean
    name?: boolean
    alias?: boolean
    description?: boolean
    personality?: boolean
    corruption?: boolean
    abilities?: boolean
    dailyEffects?: boolean
    corruptionTriggers?: boolean
    unlockRequirements?: boolean
    image?: boolean
    symbol?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | Mask$playersArgs<ExtArgs>
    currentPlayers?: boolean | Mask$currentPlayersArgs<ExtArgs>
    _count?: boolean | MaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mask"
    objects: {
      players: Prisma.$PlayerMaskPayload<ExtArgs>[]
      currentPlayers: Prisma.$PlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      alias: string
      description: string
      personality: string
      corruption: number
      abilities: Prisma.JsonValue
      dailyEffects: Prisma.JsonValue
      corruptionTriggers: string[]
      unlockRequirements: string[]
      image: string
      symbol: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mask"]>
    composites: {}
  }

  type MaskGetPayload<S extends boolean | null | undefined | MaskDefaultArgs> = $Result.GetResult<Prisma.$MaskPayload, S>

  type MaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaskCountAggregateInputType | true
    }

  export interface MaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mask'], meta: { name: 'Mask' } }
    /**
     * Find zero or one Mask that matches the filter.
     * @param {MaskFindUniqueArgs} args - Arguments to find a Mask
     * @example
     * // Get one Mask
     * const mask = await prisma.mask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaskFindUniqueArgs>(args: SelectSubset<T, MaskFindUniqueArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaskFindUniqueOrThrowArgs} args - Arguments to find a Mask
     * @example
     * // Get one Mask
     * const mask = await prisma.mask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaskFindUniqueOrThrowArgs>(args: SelectSubset<T, MaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaskFindFirstArgs} args - Arguments to find a Mask
     * @example
     * // Get one Mask
     * const mask = await prisma.mask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaskFindFirstArgs>(args?: SelectSubset<T, MaskFindFirstArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaskFindFirstOrThrowArgs} args - Arguments to find a Mask
     * @example
     * // Get one Mask
     * const mask = await prisma.mask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaskFindFirstOrThrowArgs>(args?: SelectSubset<T, MaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Masks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Masks
     * const masks = await prisma.mask.findMany()
     * 
     * // Get first 10 Masks
     * const masks = await prisma.mask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maskWithIdOnly = await prisma.mask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaskFindManyArgs>(args?: SelectSubset<T, MaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mask.
     * @param {MaskCreateArgs} args - Arguments to create a Mask.
     * @example
     * // Create one Mask
     * const Mask = await prisma.mask.create({
     *   data: {
     *     // ... data to create a Mask
     *   }
     * })
     * 
     */
    create<T extends MaskCreateArgs>(args: SelectSubset<T, MaskCreateArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Masks.
     * @param {MaskCreateManyArgs} args - Arguments to create many Masks.
     * @example
     * // Create many Masks
     * const mask = await prisma.mask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaskCreateManyArgs>(args?: SelectSubset<T, MaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Masks and returns the data saved in the database.
     * @param {MaskCreateManyAndReturnArgs} args - Arguments to create many Masks.
     * @example
     * // Create many Masks
     * const mask = await prisma.mask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Masks and only return the `id`
     * const maskWithIdOnly = await prisma.mask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaskCreateManyAndReturnArgs>(args?: SelectSubset<T, MaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mask.
     * @param {MaskDeleteArgs} args - Arguments to delete one Mask.
     * @example
     * // Delete one Mask
     * const Mask = await prisma.mask.delete({
     *   where: {
     *     // ... filter to delete one Mask
     *   }
     * })
     * 
     */
    delete<T extends MaskDeleteArgs>(args: SelectSubset<T, MaskDeleteArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mask.
     * @param {MaskUpdateArgs} args - Arguments to update one Mask.
     * @example
     * // Update one Mask
     * const mask = await prisma.mask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaskUpdateArgs>(args: SelectSubset<T, MaskUpdateArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Masks.
     * @param {MaskDeleteManyArgs} args - Arguments to filter Masks to delete.
     * @example
     * // Delete a few Masks
     * const { count } = await prisma.mask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaskDeleteManyArgs>(args?: SelectSubset<T, MaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Masks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Masks
     * const mask = await prisma.mask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaskUpdateManyArgs>(args: SelectSubset<T, MaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mask.
     * @param {MaskUpsertArgs} args - Arguments to update or create a Mask.
     * @example
     * // Update or create a Mask
     * const mask = await prisma.mask.upsert({
     *   create: {
     *     // ... data to create a Mask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mask we want to update
     *   }
     * })
     */
    upsert<T extends MaskUpsertArgs>(args: SelectSubset<T, MaskUpsertArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Masks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaskCountArgs} args - Arguments to filter Masks to count.
     * @example
     * // Count the number of Masks
     * const count = await prisma.mask.count({
     *   where: {
     *     // ... the filter for the Masks we want to count
     *   }
     * })
    **/
    count<T extends MaskCountArgs>(
      args?: Subset<T, MaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaskAggregateArgs>(args: Subset<T, MaskAggregateArgs>): Prisma.PrismaPromise<GetMaskAggregateType<T>>

    /**
     * Group by Mask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaskGroupByArgs['orderBy'] }
        : { orderBy?: MaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mask model
   */
  readonly fields: MaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    players<T extends Mask$playersArgs<ExtArgs> = {}>(args?: Subset<T, Mask$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "findMany"> | Null>
    currentPlayers<T extends Mask$currentPlayersArgs<ExtArgs> = {}>(args?: Subset<T, Mask$currentPlayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mask model
   */ 
  interface MaskFieldRefs {
    readonly id: FieldRef<"Mask", 'String'>
    readonly name: FieldRef<"Mask", 'String'>
    readonly alias: FieldRef<"Mask", 'String'>
    readonly description: FieldRef<"Mask", 'String'>
    readonly personality: FieldRef<"Mask", 'String'>
    readonly corruption: FieldRef<"Mask", 'Int'>
    readonly abilities: FieldRef<"Mask", 'Json'>
    readonly dailyEffects: FieldRef<"Mask", 'Json'>
    readonly corruptionTriggers: FieldRef<"Mask", 'String[]'>
    readonly unlockRequirements: FieldRef<"Mask", 'String[]'>
    readonly image: FieldRef<"Mask", 'String'>
    readonly symbol: FieldRef<"Mask", 'String'>
    readonly createdAt: FieldRef<"Mask", 'DateTime'>
    readonly updatedAt: FieldRef<"Mask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mask findUnique
   */
  export type MaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * Filter, which Mask to fetch.
     */
    where: MaskWhereUniqueInput
  }

  /**
   * Mask findUniqueOrThrow
   */
  export type MaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * Filter, which Mask to fetch.
     */
    where: MaskWhereUniqueInput
  }

  /**
   * Mask findFirst
   */
  export type MaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * Filter, which Mask to fetch.
     */
    where?: MaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Masks to fetch.
     */
    orderBy?: MaskOrderByWithRelationInput | MaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Masks.
     */
    cursor?: MaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Masks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Masks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Masks.
     */
    distinct?: MaskScalarFieldEnum | MaskScalarFieldEnum[]
  }

  /**
   * Mask findFirstOrThrow
   */
  export type MaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * Filter, which Mask to fetch.
     */
    where?: MaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Masks to fetch.
     */
    orderBy?: MaskOrderByWithRelationInput | MaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Masks.
     */
    cursor?: MaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Masks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Masks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Masks.
     */
    distinct?: MaskScalarFieldEnum | MaskScalarFieldEnum[]
  }

  /**
   * Mask findMany
   */
  export type MaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * Filter, which Masks to fetch.
     */
    where?: MaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Masks to fetch.
     */
    orderBy?: MaskOrderByWithRelationInput | MaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Masks.
     */
    cursor?: MaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Masks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Masks.
     */
    skip?: number
    distinct?: MaskScalarFieldEnum | MaskScalarFieldEnum[]
  }

  /**
   * Mask create
   */
  export type MaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Mask.
     */
    data: XOR<MaskCreateInput, MaskUncheckedCreateInput>
  }

  /**
   * Mask createMany
   */
  export type MaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Masks.
     */
    data: MaskCreateManyInput | MaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mask createManyAndReturn
   */
  export type MaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Masks.
     */
    data: MaskCreateManyInput | MaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mask update
   */
  export type MaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Mask.
     */
    data: XOR<MaskUpdateInput, MaskUncheckedUpdateInput>
    /**
     * Choose, which Mask to update.
     */
    where: MaskWhereUniqueInput
  }

  /**
   * Mask updateMany
   */
  export type MaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Masks.
     */
    data: XOR<MaskUpdateManyMutationInput, MaskUncheckedUpdateManyInput>
    /**
     * Filter which Masks to update
     */
    where?: MaskWhereInput
  }

  /**
   * Mask upsert
   */
  export type MaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Mask to update in case it exists.
     */
    where: MaskWhereUniqueInput
    /**
     * In case the Mask found by the `where` argument doesn't exist, create a new Mask with this data.
     */
    create: XOR<MaskCreateInput, MaskUncheckedCreateInput>
    /**
     * In case the Mask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaskUpdateInput, MaskUncheckedUpdateInput>
  }

  /**
   * Mask delete
   */
  export type MaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
    /**
     * Filter which Mask to delete.
     */
    where: MaskWhereUniqueInput
  }

  /**
   * Mask deleteMany
   */
  export type MaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Masks to delete
     */
    where?: MaskWhereInput
  }

  /**
   * Mask.players
   */
  export type Mask$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    where?: PlayerMaskWhereInput
    orderBy?: PlayerMaskOrderByWithRelationInput | PlayerMaskOrderByWithRelationInput[]
    cursor?: PlayerMaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerMaskScalarFieldEnum | PlayerMaskScalarFieldEnum[]
  }

  /**
   * Mask.currentPlayers
   */
  export type Mask$currentPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Mask without action
   */
  export type MaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mask
     */
    select?: MaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaskInclude<ExtArgs> | null
  }


  /**
   * Model PlayerMask
   */

  export type AggregatePlayerMask = {
    _count: PlayerMaskCountAggregateOutputType | null
    _avg: PlayerMaskAvgAggregateOutputType | null
    _sum: PlayerMaskSumAggregateOutputType | null
    _min: PlayerMaskMinAggregateOutputType | null
    _max: PlayerMaskMaxAggregateOutputType | null
  }

  export type PlayerMaskAvgAggregateOutputType = {
    corruption: number | null
  }

  export type PlayerMaskSumAggregateOutputType = {
    corruption: number | null
  }

  export type PlayerMaskMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    maskId: string | null
    corruption: number | null
  }

  export type PlayerMaskMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    maskId: string | null
    corruption: number | null
  }

  export type PlayerMaskCountAggregateOutputType = {
    id: number
    playerId: number
    maskId: number
    corruption: number
    _all: number
  }


  export type PlayerMaskAvgAggregateInputType = {
    corruption?: true
  }

  export type PlayerMaskSumAggregateInputType = {
    corruption?: true
  }

  export type PlayerMaskMinAggregateInputType = {
    id?: true
    playerId?: true
    maskId?: true
    corruption?: true
  }

  export type PlayerMaskMaxAggregateInputType = {
    id?: true
    playerId?: true
    maskId?: true
    corruption?: true
  }

  export type PlayerMaskCountAggregateInputType = {
    id?: true
    playerId?: true
    maskId?: true
    corruption?: true
    _all?: true
  }

  export type PlayerMaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerMask to aggregate.
     */
    where?: PlayerMaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMasks to fetch.
     */
    orderBy?: PlayerMaskOrderByWithRelationInput | PlayerMaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerMaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerMasks
    **/
    _count?: true | PlayerMaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerMaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerMaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaskMaxAggregateInputType
  }

  export type GetPlayerMaskAggregateType<T extends PlayerMaskAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerMask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerMask[P]>
      : GetScalarType<T[P], AggregatePlayerMask[P]>
  }




  export type PlayerMaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMaskWhereInput
    orderBy?: PlayerMaskOrderByWithAggregationInput | PlayerMaskOrderByWithAggregationInput[]
    by: PlayerMaskScalarFieldEnum[] | PlayerMaskScalarFieldEnum
    having?: PlayerMaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerMaskCountAggregateInputType | true
    _avg?: PlayerMaskAvgAggregateInputType
    _sum?: PlayerMaskSumAggregateInputType
    _min?: PlayerMaskMinAggregateInputType
    _max?: PlayerMaskMaxAggregateInputType
  }

  export type PlayerMaskGroupByOutputType = {
    id: string
    playerId: string
    maskId: string
    corruption: number
    _count: PlayerMaskCountAggregateOutputType | null
    _avg: PlayerMaskAvgAggregateOutputType | null
    _sum: PlayerMaskSumAggregateOutputType | null
    _min: PlayerMaskMinAggregateOutputType | null
    _max: PlayerMaskMaxAggregateOutputType | null
  }

  type GetPlayerMaskGroupByPayload<T extends PlayerMaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerMaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerMaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerMaskGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerMaskGroupByOutputType[P]>
        }
      >
    >


  export type PlayerMaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    maskId?: boolean
    corruption?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    mask?: boolean | MaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerMask"]>

  export type PlayerMaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    maskId?: boolean
    corruption?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    mask?: boolean | MaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerMask"]>

  export type PlayerMaskSelectScalar = {
    id?: boolean
    playerId?: boolean
    maskId?: boolean
    corruption?: boolean
  }

  export type PlayerMaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    mask?: boolean | MaskDefaultArgs<ExtArgs>
  }
  export type PlayerMaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    mask?: boolean | MaskDefaultArgs<ExtArgs>
  }

  export type $PlayerMaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerMask"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      mask: Prisma.$MaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      maskId: string
      corruption: number
    }, ExtArgs["result"]["playerMask"]>
    composites: {}
  }

  type PlayerMaskGetPayload<S extends boolean | null | undefined | PlayerMaskDefaultArgs> = $Result.GetResult<Prisma.$PlayerMaskPayload, S>

  type PlayerMaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerMaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerMaskCountAggregateInputType | true
    }

  export interface PlayerMaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerMask'], meta: { name: 'PlayerMask' } }
    /**
     * Find zero or one PlayerMask that matches the filter.
     * @param {PlayerMaskFindUniqueArgs} args - Arguments to find a PlayerMask
     * @example
     * // Get one PlayerMask
     * const playerMask = await prisma.playerMask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerMaskFindUniqueArgs>(args: SelectSubset<T, PlayerMaskFindUniqueArgs<ExtArgs>>): Prisma__PlayerMaskClient<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerMask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerMaskFindUniqueOrThrowArgs} args - Arguments to find a PlayerMask
     * @example
     * // Get one PlayerMask
     * const playerMask = await prisma.playerMask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerMaskFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerMaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerMaskClient<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerMask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMaskFindFirstArgs} args - Arguments to find a PlayerMask
     * @example
     * // Get one PlayerMask
     * const playerMask = await prisma.playerMask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerMaskFindFirstArgs>(args?: SelectSubset<T, PlayerMaskFindFirstArgs<ExtArgs>>): Prisma__PlayerMaskClient<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerMask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMaskFindFirstOrThrowArgs} args - Arguments to find a PlayerMask
     * @example
     * // Get one PlayerMask
     * const playerMask = await prisma.playerMask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerMaskFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerMaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerMaskClient<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerMasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerMasks
     * const playerMasks = await prisma.playerMask.findMany()
     * 
     * // Get first 10 PlayerMasks
     * const playerMasks = await prisma.playerMask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerMaskWithIdOnly = await prisma.playerMask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerMaskFindManyArgs>(args?: SelectSubset<T, PlayerMaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerMask.
     * @param {PlayerMaskCreateArgs} args - Arguments to create a PlayerMask.
     * @example
     * // Create one PlayerMask
     * const PlayerMask = await prisma.playerMask.create({
     *   data: {
     *     // ... data to create a PlayerMask
     *   }
     * })
     * 
     */
    create<T extends PlayerMaskCreateArgs>(args: SelectSubset<T, PlayerMaskCreateArgs<ExtArgs>>): Prisma__PlayerMaskClient<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerMasks.
     * @param {PlayerMaskCreateManyArgs} args - Arguments to create many PlayerMasks.
     * @example
     * // Create many PlayerMasks
     * const playerMask = await prisma.playerMask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerMaskCreateManyArgs>(args?: SelectSubset<T, PlayerMaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerMasks and returns the data saved in the database.
     * @param {PlayerMaskCreateManyAndReturnArgs} args - Arguments to create many PlayerMasks.
     * @example
     * // Create many PlayerMasks
     * const playerMask = await prisma.playerMask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerMasks and only return the `id`
     * const playerMaskWithIdOnly = await prisma.playerMask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerMaskCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerMaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerMask.
     * @param {PlayerMaskDeleteArgs} args - Arguments to delete one PlayerMask.
     * @example
     * // Delete one PlayerMask
     * const PlayerMask = await prisma.playerMask.delete({
     *   where: {
     *     // ... filter to delete one PlayerMask
     *   }
     * })
     * 
     */
    delete<T extends PlayerMaskDeleteArgs>(args: SelectSubset<T, PlayerMaskDeleteArgs<ExtArgs>>): Prisma__PlayerMaskClient<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerMask.
     * @param {PlayerMaskUpdateArgs} args - Arguments to update one PlayerMask.
     * @example
     * // Update one PlayerMask
     * const playerMask = await prisma.playerMask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerMaskUpdateArgs>(args: SelectSubset<T, PlayerMaskUpdateArgs<ExtArgs>>): Prisma__PlayerMaskClient<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerMasks.
     * @param {PlayerMaskDeleteManyArgs} args - Arguments to filter PlayerMasks to delete.
     * @example
     * // Delete a few PlayerMasks
     * const { count } = await prisma.playerMask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerMaskDeleteManyArgs>(args?: SelectSubset<T, PlayerMaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerMasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerMasks
     * const playerMask = await prisma.playerMask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerMaskUpdateManyArgs>(args: SelectSubset<T, PlayerMaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerMask.
     * @param {PlayerMaskUpsertArgs} args - Arguments to update or create a PlayerMask.
     * @example
     * // Update or create a PlayerMask
     * const playerMask = await prisma.playerMask.upsert({
     *   create: {
     *     // ... data to create a PlayerMask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerMask we want to update
     *   }
     * })
     */
    upsert<T extends PlayerMaskUpsertArgs>(args: SelectSubset<T, PlayerMaskUpsertArgs<ExtArgs>>): Prisma__PlayerMaskClient<$Result.GetResult<Prisma.$PlayerMaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerMasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMaskCountArgs} args - Arguments to filter PlayerMasks to count.
     * @example
     * // Count the number of PlayerMasks
     * const count = await prisma.playerMask.count({
     *   where: {
     *     // ... the filter for the PlayerMasks we want to count
     *   }
     * })
    **/
    count<T extends PlayerMaskCountArgs>(
      args?: Subset<T, PlayerMaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerMaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerMask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerMaskAggregateArgs>(args: Subset<T, PlayerMaskAggregateArgs>): Prisma.PrismaPromise<GetPlayerMaskAggregateType<T>>

    /**
     * Group by PlayerMask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerMaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerMaskGroupByArgs['orderBy'] }
        : { orderBy?: PlayerMaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerMaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerMaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerMask model
   */
  readonly fields: PlayerMaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerMask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerMaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mask<T extends MaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaskDefaultArgs<ExtArgs>>): Prisma__MaskClient<$Result.GetResult<Prisma.$MaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerMask model
   */ 
  interface PlayerMaskFieldRefs {
    readonly id: FieldRef<"PlayerMask", 'String'>
    readonly playerId: FieldRef<"PlayerMask", 'String'>
    readonly maskId: FieldRef<"PlayerMask", 'String'>
    readonly corruption: FieldRef<"PlayerMask", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlayerMask findUnique
   */
  export type PlayerMaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMask to fetch.
     */
    where: PlayerMaskWhereUniqueInput
  }

  /**
   * PlayerMask findUniqueOrThrow
   */
  export type PlayerMaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMask to fetch.
     */
    where: PlayerMaskWhereUniqueInput
  }

  /**
   * PlayerMask findFirst
   */
  export type PlayerMaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMask to fetch.
     */
    where?: PlayerMaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMasks to fetch.
     */
    orderBy?: PlayerMaskOrderByWithRelationInput | PlayerMaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerMasks.
     */
    cursor?: PlayerMaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerMasks.
     */
    distinct?: PlayerMaskScalarFieldEnum | PlayerMaskScalarFieldEnum[]
  }

  /**
   * PlayerMask findFirstOrThrow
   */
  export type PlayerMaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMask to fetch.
     */
    where?: PlayerMaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMasks to fetch.
     */
    orderBy?: PlayerMaskOrderByWithRelationInput | PlayerMaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerMasks.
     */
    cursor?: PlayerMaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerMasks.
     */
    distinct?: PlayerMaskScalarFieldEnum | PlayerMaskScalarFieldEnum[]
  }

  /**
   * PlayerMask findMany
   */
  export type PlayerMaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMasks to fetch.
     */
    where?: PlayerMaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMasks to fetch.
     */
    orderBy?: PlayerMaskOrderByWithRelationInput | PlayerMaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerMasks.
     */
    cursor?: PlayerMaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMasks.
     */
    skip?: number
    distinct?: PlayerMaskScalarFieldEnum | PlayerMaskScalarFieldEnum[]
  }

  /**
   * PlayerMask create
   */
  export type PlayerMaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerMask.
     */
    data: XOR<PlayerMaskCreateInput, PlayerMaskUncheckedCreateInput>
  }

  /**
   * PlayerMask createMany
   */
  export type PlayerMaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerMasks.
     */
    data: PlayerMaskCreateManyInput | PlayerMaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerMask createManyAndReturn
   */
  export type PlayerMaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerMasks.
     */
    data: PlayerMaskCreateManyInput | PlayerMaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerMask update
   */
  export type PlayerMaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerMask.
     */
    data: XOR<PlayerMaskUpdateInput, PlayerMaskUncheckedUpdateInput>
    /**
     * Choose, which PlayerMask to update.
     */
    where: PlayerMaskWhereUniqueInput
  }

  /**
   * PlayerMask updateMany
   */
  export type PlayerMaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerMasks.
     */
    data: XOR<PlayerMaskUpdateManyMutationInput, PlayerMaskUncheckedUpdateManyInput>
    /**
     * Filter which PlayerMasks to update
     */
    where?: PlayerMaskWhereInput
  }

  /**
   * PlayerMask upsert
   */
  export type PlayerMaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerMask to update in case it exists.
     */
    where: PlayerMaskWhereUniqueInput
    /**
     * In case the PlayerMask found by the `where` argument doesn't exist, create a new PlayerMask with this data.
     */
    create: XOR<PlayerMaskCreateInput, PlayerMaskUncheckedCreateInput>
    /**
     * In case the PlayerMask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerMaskUpdateInput, PlayerMaskUncheckedUpdateInput>
  }

  /**
   * PlayerMask delete
   */
  export type PlayerMaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
    /**
     * Filter which PlayerMask to delete.
     */
    where: PlayerMaskWhereUniqueInput
  }

  /**
   * PlayerMask deleteMany
   */
  export type PlayerMaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerMasks to delete
     */
    where?: PlayerMaskWhereInput
  }

  /**
   * PlayerMask without action
   */
  export type PlayerMaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMask
     */
    select?: PlayerMaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMaskInclude<ExtArgs> | null
  }


  /**
   * Model NPC
   */

  export type AggregateNPC = {
    _count: NPCCountAggregateOutputType | null
    _avg: NPCAvgAggregateOutputType | null
    _sum: NPCSumAggregateOutputType | null
    _min: NPCMinAggregateOutputType | null
    _max: NPCMaxAggregateOutputType | null
  }

  export type NPCAvgAggregateOutputType = {
    relationship: number | null
    rumorScore: number | null
  }

  export type NPCSumAggregateOutputType = {
    relationship: number | null
    rumorScore: number | null
  }

  export type NPCMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    personality: string | null
    relationship: number | null
    rumorScore: number | null
    portrait: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NPCMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    personality: string | null
    relationship: number | null
    rumorScore: number | null
    portrait: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NPCCountAggregateOutputType = {
    id: number
    name: number
    role: number
    traits: number
    personality: number
    schedule: number
    relationship: number
    rumorScore: number
    reactions: number
    events: number
    portrait: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NPCAvgAggregateInputType = {
    relationship?: true
    rumorScore?: true
  }

  export type NPCSumAggregateInputType = {
    relationship?: true
    rumorScore?: true
  }

  export type NPCMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    personality?: true
    relationship?: true
    rumorScore?: true
    portrait?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NPCMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    personality?: true
    relationship?: true
    rumorScore?: true
    portrait?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NPCCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    traits?: true
    personality?: true
    schedule?: true
    relationship?: true
    rumorScore?: true
    reactions?: true
    events?: true
    portrait?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NPCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPC to aggregate.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NPCS
    **/
    _count?: true | NPCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NPCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NPCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NPCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NPCMaxAggregateInputType
  }

  export type GetNPCAggregateType<T extends NPCAggregateArgs> = {
        [P in keyof T & keyof AggregateNPC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNPC[P]>
      : GetScalarType<T[P], AggregateNPC[P]>
  }




  export type NPCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithAggregationInput | NPCOrderByWithAggregationInput[]
    by: NPCScalarFieldEnum[] | NPCScalarFieldEnum
    having?: NPCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NPCCountAggregateInputType | true
    _avg?: NPCAvgAggregateInputType
    _sum?: NPCSumAggregateInputType
    _min?: NPCMinAggregateInputType
    _max?: NPCMaxAggregateInputType
  }

  export type NPCGroupByOutputType = {
    id: string
    name: string
    role: string
    traits: string[]
    personality: string
    schedule: JsonValue
    relationship: number
    rumorScore: number
    reactions: JsonValue
    events: string[]
    portrait: string
    zoneId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NPCCountAggregateOutputType | null
    _avg: NPCAvgAggregateOutputType | null
    _sum: NPCSumAggregateOutputType | null
    _min: NPCMinAggregateOutputType | null
    _max: NPCMaxAggregateOutputType | null
  }

  type GetNPCGroupByPayload<T extends NPCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NPCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NPCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NPCGroupByOutputType[P]>
            : GetScalarType<T[P], NPCGroupByOutputType[P]>
        }
      >
    >


  export type NPCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    traits?: boolean
    personality?: boolean
    schedule?: boolean
    relationship?: boolean
    rumorScore?: boolean
    reactions?: boolean
    events?: boolean
    portrait?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | NPC$locationArgs<ExtArgs>
    playerRelationships?: boolean | NPC$playerRelationshipsArgs<ExtArgs>
    _count?: boolean | NPCCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    traits?: boolean
    personality?: boolean
    schedule?: boolean
    relationship?: boolean
    rumorScore?: boolean
    reactions?: boolean
    events?: boolean
    portrait?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | NPC$locationArgs<ExtArgs>
  }, ExtArgs["result"]["nPC"]>

  export type NPCSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    traits?: boolean
    personality?: boolean
    schedule?: boolean
    relationship?: boolean
    rumorScore?: boolean
    reactions?: boolean
    events?: boolean
    portrait?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NPCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | NPC$locationArgs<ExtArgs>
    playerRelationships?: boolean | NPC$playerRelationshipsArgs<ExtArgs>
    _count?: boolean | NPCCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NPCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | NPC$locationArgs<ExtArgs>
  }

  export type $NPCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NPC"
    objects: {
      location: Prisma.$ZonePayload<ExtArgs> | null
      playerRelationships: Prisma.$PlayerRelationshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      traits: string[]
      personality: string
      schedule: Prisma.JsonValue
      relationship: number
      rumorScore: number
      reactions: Prisma.JsonValue
      events: string[]
      portrait: string
      zoneId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nPC"]>
    composites: {}
  }

  type NPCGetPayload<S extends boolean | null | undefined | NPCDefaultArgs> = $Result.GetResult<Prisma.$NPCPayload, S>

  type NPCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NPCFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NPCCountAggregateInputType | true
    }

  export interface NPCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NPC'], meta: { name: 'NPC' } }
    /**
     * Find zero or one NPC that matches the filter.
     * @param {NPCFindUniqueArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NPCFindUniqueArgs>(args: SelectSubset<T, NPCFindUniqueArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NPC that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NPCFindUniqueOrThrowArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NPCFindUniqueOrThrowArgs>(args: SelectSubset<T, NPCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NPC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindFirstArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NPCFindFirstArgs>(args?: SelectSubset<T, NPCFindFirstArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NPC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindFirstOrThrowArgs} args - Arguments to find a NPC
     * @example
     * // Get one NPC
     * const nPC = await prisma.nPC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NPCFindFirstOrThrowArgs>(args?: SelectSubset<T, NPCFindFirstOrThrowArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NPCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NPCS
     * const nPCS = await prisma.nPC.findMany()
     * 
     * // Get first 10 NPCS
     * const nPCS = await prisma.nPC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nPCWithIdOnly = await prisma.nPC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NPCFindManyArgs>(args?: SelectSubset<T, NPCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NPC.
     * @param {NPCCreateArgs} args - Arguments to create a NPC.
     * @example
     * // Create one NPC
     * const NPC = await prisma.nPC.create({
     *   data: {
     *     // ... data to create a NPC
     *   }
     * })
     * 
     */
    create<T extends NPCCreateArgs>(args: SelectSubset<T, NPCCreateArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NPCS.
     * @param {NPCCreateManyArgs} args - Arguments to create many NPCS.
     * @example
     * // Create many NPCS
     * const nPC = await prisma.nPC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NPCCreateManyArgs>(args?: SelectSubset<T, NPCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NPCS and returns the data saved in the database.
     * @param {NPCCreateManyAndReturnArgs} args - Arguments to create many NPCS.
     * @example
     * // Create many NPCS
     * const nPC = await prisma.nPC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NPCS and only return the `id`
     * const nPCWithIdOnly = await prisma.nPC.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NPCCreateManyAndReturnArgs>(args?: SelectSubset<T, NPCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a NPC.
     * @param {NPCDeleteArgs} args - Arguments to delete one NPC.
     * @example
     * // Delete one NPC
     * const NPC = await prisma.nPC.delete({
     *   where: {
     *     // ... filter to delete one NPC
     *   }
     * })
     * 
     */
    delete<T extends NPCDeleteArgs>(args: SelectSubset<T, NPCDeleteArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NPC.
     * @param {NPCUpdateArgs} args - Arguments to update one NPC.
     * @example
     * // Update one NPC
     * const nPC = await prisma.nPC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NPCUpdateArgs>(args: SelectSubset<T, NPCUpdateArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NPCS.
     * @param {NPCDeleteManyArgs} args - Arguments to filter NPCS to delete.
     * @example
     * // Delete a few NPCS
     * const { count } = await prisma.nPC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NPCDeleteManyArgs>(args?: SelectSubset<T, NPCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NPCS
     * const nPC = await prisma.nPC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NPCUpdateManyArgs>(args: SelectSubset<T, NPCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NPC.
     * @param {NPCUpsertArgs} args - Arguments to update or create a NPC.
     * @example
     * // Update or create a NPC
     * const nPC = await prisma.nPC.upsert({
     *   create: {
     *     // ... data to create a NPC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NPC we want to update
     *   }
     * })
     */
    upsert<T extends NPCUpsertArgs>(args: SelectSubset<T, NPCUpsertArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NPCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCCountArgs} args - Arguments to filter NPCS to count.
     * @example
     * // Count the number of NPCS
     * const count = await prisma.nPC.count({
     *   where: {
     *     // ... the filter for the NPCS we want to count
     *   }
     * })
    **/
    count<T extends NPCCountArgs>(
      args?: Subset<T, NPCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NPCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NPCAggregateArgs>(args: Subset<T, NPCAggregateArgs>): Prisma.PrismaPromise<GetNPCAggregateType<T>>

    /**
     * Group by NPC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NPCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NPCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NPCGroupByArgs['orderBy'] }
        : { orderBy?: NPCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NPCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNPCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NPC model
   */
  readonly fields: NPCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NPC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NPCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends NPC$locationArgs<ExtArgs> = {}>(args?: Subset<T, NPC$locationArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    playerRelationships<T extends NPC$playerRelationshipsArgs<ExtArgs> = {}>(args?: Subset<T, NPC$playerRelationshipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NPC model
   */ 
  interface NPCFieldRefs {
    readonly id: FieldRef<"NPC", 'String'>
    readonly name: FieldRef<"NPC", 'String'>
    readonly role: FieldRef<"NPC", 'String'>
    readonly traits: FieldRef<"NPC", 'String[]'>
    readonly personality: FieldRef<"NPC", 'String'>
    readonly schedule: FieldRef<"NPC", 'Json'>
    readonly relationship: FieldRef<"NPC", 'Int'>
    readonly rumorScore: FieldRef<"NPC", 'Int'>
    readonly reactions: FieldRef<"NPC", 'Json'>
    readonly events: FieldRef<"NPC", 'String[]'>
    readonly portrait: FieldRef<"NPC", 'String'>
    readonly zoneId: FieldRef<"NPC", 'String'>
    readonly createdAt: FieldRef<"NPC", 'DateTime'>
    readonly updatedAt: FieldRef<"NPC", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NPC findUnique
   */
  export type NPCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC findUniqueOrThrow
   */
  export type NPCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC findFirst
   */
  export type NPCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCS.
     */
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC findFirstOrThrow
   */
  export type NPCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPC to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NPCS.
     */
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC findMany
   */
  export type NPCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter, which NPCS to fetch.
     */
    where?: NPCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NPCS to fetch.
     */
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NPCS.
     */
    cursor?: NPCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NPCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NPCS.
     */
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * NPC create
   */
  export type NPCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The data needed to create a NPC.
     */
    data: XOR<NPCCreateInput, NPCUncheckedCreateInput>
  }

  /**
   * NPC createMany
   */
  export type NPCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NPCS.
     */
    data: NPCCreateManyInput | NPCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NPC createManyAndReturn
   */
  export type NPCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many NPCS.
     */
    data: NPCCreateManyInput | NPCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NPC update
   */
  export type NPCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The data needed to update a NPC.
     */
    data: XOR<NPCUpdateInput, NPCUncheckedUpdateInput>
    /**
     * Choose, which NPC to update.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC updateMany
   */
  export type NPCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NPCS.
     */
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyInput>
    /**
     * Filter which NPCS to update
     */
    where?: NPCWhereInput
  }

  /**
   * NPC upsert
   */
  export type NPCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * The filter to search for the NPC to update in case it exists.
     */
    where: NPCWhereUniqueInput
    /**
     * In case the NPC found by the `where` argument doesn't exist, create a new NPC with this data.
     */
    create: XOR<NPCCreateInput, NPCUncheckedCreateInput>
    /**
     * In case the NPC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NPCUpdateInput, NPCUncheckedUpdateInput>
  }

  /**
   * NPC delete
   */
  export type NPCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    /**
     * Filter which NPC to delete.
     */
    where: NPCWhereUniqueInput
  }

  /**
   * NPC deleteMany
   */
  export type NPCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NPCS to delete
     */
    where?: NPCWhereInput
  }

  /**
   * NPC.location
   */
  export type NPC$locationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * NPC.playerRelationships
   */
  export type NPC$playerRelationshipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    where?: PlayerRelationshipWhereInput
    orderBy?: PlayerRelationshipOrderByWithRelationInput | PlayerRelationshipOrderByWithRelationInput[]
    cursor?: PlayerRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerRelationshipScalarFieldEnum | PlayerRelationshipScalarFieldEnum[]
  }

  /**
   * NPC without action
   */
  export type NPCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZoneMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ZoneCountAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    npcs?: boolean | Zone$npcsArgs<ExtArgs>
    players?: boolean | Zone$playersArgs<ExtArgs>
    events?: boolean | Zone$eventsArgs<ExtArgs>
    actions?: boolean | Zone$actionsArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    npcs?: boolean | Zone$npcsArgs<ExtArgs>
    players?: boolean | Zone$playersArgs<ExtArgs>
    events?: boolean | Zone$eventsArgs<ExtArgs>
    actions?: boolean | Zone$actionsArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      npcs: Prisma.$NPCPayload<ExtArgs>[]
      players: Prisma.$PlayerPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      actions: Prisma.$ActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    npcs<T extends Zone$npcsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$npcsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findMany"> | Null>
    players<T extends Zone$playersArgs<ExtArgs> = {}>(args?: Subset<T, Zone$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Zone$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    actions<T extends Zone$actionsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */ 
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly type: FieldRef<"Zone", 'String'>
    readonly description: FieldRef<"Zone", 'String'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone.npcs
   */
  export type Zone$npcsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NPC
     */
    select?: NPCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NPCInclude<ExtArgs> | null
    where?: NPCWhereInput
    orderBy?: NPCOrderByWithRelationInput | NPCOrderByWithRelationInput[]
    cursor?: NPCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NPCScalarFieldEnum | NPCScalarFieldEnum[]
  }

  /**
   * Zone.players
   */
  export type Zone$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Zone.events
   */
  export type Zone$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Zone.actions
   */
  export type Zone$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    cursor?: ActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    description: string | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    effects: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    effects?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    name: string
    type: string
    description: string
    effects: JsonValue
    image: string
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    effects?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    players?: boolean | Item$playersArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    effects?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    effects?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | Item$playersArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      players: Prisma.$PlayerItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      description: string
      effects: Prisma.JsonValue
      image: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    players<T extends Item$playersArgs<ExtArgs> = {}>(args?: Subset<T, Item$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly type: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly effects: FieldRef<"Item", 'Json'>
    readonly image: FieldRef<"Item", 'String'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }

  /**
   * Item.players
   */
  export type Item$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    where?: PlayerItemWhereInput
    orderBy?: PlayerItemOrderByWithRelationInput | PlayerItemOrderByWithRelationInput[]
    cursor?: PlayerItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerItemScalarFieldEnum | PlayerItemScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model PlayerItem
   */

  export type AggregatePlayerItem = {
    _count: PlayerItemCountAggregateOutputType | null
    _avg: PlayerItemAvgAggregateOutputType | null
    _sum: PlayerItemSumAggregateOutputType | null
    _min: PlayerItemMinAggregateOutputType | null
    _max: PlayerItemMaxAggregateOutputType | null
  }

  export type PlayerItemAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PlayerItemSumAggregateOutputType = {
    quantity: number | null
  }

  export type PlayerItemMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    itemId: string | null
    quantity: number | null
  }

  export type PlayerItemMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    itemId: string | null
    quantity: number | null
  }

  export type PlayerItemCountAggregateOutputType = {
    id: number
    playerId: number
    itemId: number
    quantity: number
    _all: number
  }


  export type PlayerItemAvgAggregateInputType = {
    quantity?: true
  }

  export type PlayerItemSumAggregateInputType = {
    quantity?: true
  }

  export type PlayerItemMinAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
  }

  export type PlayerItemMaxAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
  }

  export type PlayerItemCountAggregateInputType = {
    id?: true
    playerId?: true
    itemId?: true
    quantity?: true
    _all?: true
  }

  export type PlayerItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerItem to aggregate.
     */
    where?: PlayerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItems to fetch.
     */
    orderBy?: PlayerItemOrderByWithRelationInput | PlayerItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerItems
    **/
    _count?: true | PlayerItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerItemMaxAggregateInputType
  }

  export type GetPlayerItemAggregateType<T extends PlayerItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerItem[P]>
      : GetScalarType<T[P], AggregatePlayerItem[P]>
  }




  export type PlayerItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerItemWhereInput
    orderBy?: PlayerItemOrderByWithAggregationInput | PlayerItemOrderByWithAggregationInput[]
    by: PlayerItemScalarFieldEnum[] | PlayerItemScalarFieldEnum
    having?: PlayerItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerItemCountAggregateInputType | true
    _avg?: PlayerItemAvgAggregateInputType
    _sum?: PlayerItemSumAggregateInputType
    _min?: PlayerItemMinAggregateInputType
    _max?: PlayerItemMaxAggregateInputType
  }

  export type PlayerItemGroupByOutputType = {
    id: string
    playerId: string
    itemId: string
    quantity: number
    _count: PlayerItemCountAggregateOutputType | null
    _avg: PlayerItemAvgAggregateOutputType | null
    _sum: PlayerItemSumAggregateOutputType | null
    _min: PlayerItemMinAggregateOutputType | null
    _max: PlayerItemMaxAggregateOutputType | null
  }

  type GetPlayerItemGroupByPayload<T extends PlayerItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerItemGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerItemGroupByOutputType[P]>
        }
      >
    >


  export type PlayerItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerItem"]>

  export type PlayerItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerItem"]>

  export type PlayerItemSelectScalar = {
    id?: boolean
    playerId?: boolean
    itemId?: boolean
    quantity?: boolean
  }

  export type PlayerItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type PlayerItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $PlayerItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerItem"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      itemId: string
      quantity: number
    }, ExtArgs["result"]["playerItem"]>
    composites: {}
  }

  type PlayerItemGetPayload<S extends boolean | null | undefined | PlayerItemDefaultArgs> = $Result.GetResult<Prisma.$PlayerItemPayload, S>

  type PlayerItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerItemCountAggregateInputType | true
    }

  export interface PlayerItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerItem'], meta: { name: 'PlayerItem' } }
    /**
     * Find zero or one PlayerItem that matches the filter.
     * @param {PlayerItemFindUniqueArgs} args - Arguments to find a PlayerItem
     * @example
     * // Get one PlayerItem
     * const playerItem = await prisma.playerItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerItemFindUniqueArgs>(args: SelectSubset<T, PlayerItemFindUniqueArgs<ExtArgs>>): Prisma__PlayerItemClient<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerItemFindUniqueOrThrowArgs} args - Arguments to find a PlayerItem
     * @example
     * // Get one PlayerItem
     * const playerItem = await prisma.playerItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerItemClient<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemFindFirstArgs} args - Arguments to find a PlayerItem
     * @example
     * // Get one PlayerItem
     * const playerItem = await prisma.playerItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerItemFindFirstArgs>(args?: SelectSubset<T, PlayerItemFindFirstArgs<ExtArgs>>): Prisma__PlayerItemClient<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemFindFirstOrThrowArgs} args - Arguments to find a PlayerItem
     * @example
     * // Get one PlayerItem
     * const playerItem = await prisma.playerItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerItemClient<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerItems
     * const playerItems = await prisma.playerItem.findMany()
     * 
     * // Get first 10 PlayerItems
     * const playerItems = await prisma.playerItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerItemWithIdOnly = await prisma.playerItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerItemFindManyArgs>(args?: SelectSubset<T, PlayerItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerItem.
     * @param {PlayerItemCreateArgs} args - Arguments to create a PlayerItem.
     * @example
     * // Create one PlayerItem
     * const PlayerItem = await prisma.playerItem.create({
     *   data: {
     *     // ... data to create a PlayerItem
     *   }
     * })
     * 
     */
    create<T extends PlayerItemCreateArgs>(args: SelectSubset<T, PlayerItemCreateArgs<ExtArgs>>): Prisma__PlayerItemClient<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerItems.
     * @param {PlayerItemCreateManyArgs} args - Arguments to create many PlayerItems.
     * @example
     * // Create many PlayerItems
     * const playerItem = await prisma.playerItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerItemCreateManyArgs>(args?: SelectSubset<T, PlayerItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerItems and returns the data saved in the database.
     * @param {PlayerItemCreateManyAndReturnArgs} args - Arguments to create many PlayerItems.
     * @example
     * // Create many PlayerItems
     * const playerItem = await prisma.playerItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerItems and only return the `id`
     * const playerItemWithIdOnly = await prisma.playerItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerItem.
     * @param {PlayerItemDeleteArgs} args - Arguments to delete one PlayerItem.
     * @example
     * // Delete one PlayerItem
     * const PlayerItem = await prisma.playerItem.delete({
     *   where: {
     *     // ... filter to delete one PlayerItem
     *   }
     * })
     * 
     */
    delete<T extends PlayerItemDeleteArgs>(args: SelectSubset<T, PlayerItemDeleteArgs<ExtArgs>>): Prisma__PlayerItemClient<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerItem.
     * @param {PlayerItemUpdateArgs} args - Arguments to update one PlayerItem.
     * @example
     * // Update one PlayerItem
     * const playerItem = await prisma.playerItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerItemUpdateArgs>(args: SelectSubset<T, PlayerItemUpdateArgs<ExtArgs>>): Prisma__PlayerItemClient<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerItems.
     * @param {PlayerItemDeleteManyArgs} args - Arguments to filter PlayerItems to delete.
     * @example
     * // Delete a few PlayerItems
     * const { count } = await prisma.playerItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerItemDeleteManyArgs>(args?: SelectSubset<T, PlayerItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerItems
     * const playerItem = await prisma.playerItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerItemUpdateManyArgs>(args: SelectSubset<T, PlayerItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerItem.
     * @param {PlayerItemUpsertArgs} args - Arguments to update or create a PlayerItem.
     * @example
     * // Update or create a PlayerItem
     * const playerItem = await prisma.playerItem.upsert({
     *   create: {
     *     // ... data to create a PlayerItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerItem we want to update
     *   }
     * })
     */
    upsert<T extends PlayerItemUpsertArgs>(args: SelectSubset<T, PlayerItemUpsertArgs<ExtArgs>>): Prisma__PlayerItemClient<$Result.GetResult<Prisma.$PlayerItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemCountArgs} args - Arguments to filter PlayerItems to count.
     * @example
     * // Count the number of PlayerItems
     * const count = await prisma.playerItem.count({
     *   where: {
     *     // ... the filter for the PlayerItems we want to count
     *   }
     * })
    **/
    count<T extends PlayerItemCountArgs>(
      args?: Subset<T, PlayerItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerItemAggregateArgs>(args: Subset<T, PlayerItemAggregateArgs>): Prisma.PrismaPromise<GetPlayerItemAggregateType<T>>

    /**
     * Group by PlayerItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerItemGroupByArgs['orderBy'] }
        : { orderBy?: PlayerItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerItem model
   */
  readonly fields: PlayerItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerItem model
   */ 
  interface PlayerItemFieldRefs {
    readonly id: FieldRef<"PlayerItem", 'String'>
    readonly playerId: FieldRef<"PlayerItem", 'String'>
    readonly itemId: FieldRef<"PlayerItem", 'String'>
    readonly quantity: FieldRef<"PlayerItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlayerItem findUnique
   */
  export type PlayerItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlayerItem to fetch.
     */
    where: PlayerItemWhereUniqueInput
  }

  /**
   * PlayerItem findUniqueOrThrow
   */
  export type PlayerItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlayerItem to fetch.
     */
    where: PlayerItemWhereUniqueInput
  }

  /**
   * PlayerItem findFirst
   */
  export type PlayerItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlayerItem to fetch.
     */
    where?: PlayerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItems to fetch.
     */
    orderBy?: PlayerItemOrderByWithRelationInput | PlayerItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerItems.
     */
    cursor?: PlayerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerItems.
     */
    distinct?: PlayerItemScalarFieldEnum | PlayerItemScalarFieldEnum[]
  }

  /**
   * PlayerItem findFirstOrThrow
   */
  export type PlayerItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlayerItem to fetch.
     */
    where?: PlayerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItems to fetch.
     */
    orderBy?: PlayerItemOrderByWithRelationInput | PlayerItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerItems.
     */
    cursor?: PlayerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerItems.
     */
    distinct?: PlayerItemScalarFieldEnum | PlayerItemScalarFieldEnum[]
  }

  /**
   * PlayerItem findMany
   */
  export type PlayerItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlayerItems to fetch.
     */
    where?: PlayerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerItems to fetch.
     */
    orderBy?: PlayerItemOrderByWithRelationInput | PlayerItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerItems.
     */
    cursor?: PlayerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerItems.
     */
    skip?: number
    distinct?: PlayerItemScalarFieldEnum | PlayerItemScalarFieldEnum[]
  }

  /**
   * PlayerItem create
   */
  export type PlayerItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerItem.
     */
    data: XOR<PlayerItemCreateInput, PlayerItemUncheckedCreateInput>
  }

  /**
   * PlayerItem createMany
   */
  export type PlayerItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerItems.
     */
    data: PlayerItemCreateManyInput | PlayerItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerItem createManyAndReturn
   */
  export type PlayerItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerItems.
     */
    data: PlayerItemCreateManyInput | PlayerItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerItem update
   */
  export type PlayerItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerItem.
     */
    data: XOR<PlayerItemUpdateInput, PlayerItemUncheckedUpdateInput>
    /**
     * Choose, which PlayerItem to update.
     */
    where: PlayerItemWhereUniqueInput
  }

  /**
   * PlayerItem updateMany
   */
  export type PlayerItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerItems.
     */
    data: XOR<PlayerItemUpdateManyMutationInput, PlayerItemUncheckedUpdateManyInput>
    /**
     * Filter which PlayerItems to update
     */
    where?: PlayerItemWhereInput
  }

  /**
   * PlayerItem upsert
   */
  export type PlayerItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerItem to update in case it exists.
     */
    where: PlayerItemWhereUniqueInput
    /**
     * In case the PlayerItem found by the `where` argument doesn't exist, create a new PlayerItem with this data.
     */
    create: XOR<PlayerItemCreateInput, PlayerItemUncheckedCreateInput>
    /**
     * In case the PlayerItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerItemUpdateInput, PlayerItemUncheckedUpdateInput>
  }

  /**
   * PlayerItem delete
   */
  export type PlayerItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
    /**
     * Filter which PlayerItem to delete.
     */
    where: PlayerItemWhereUniqueInput
  }

  /**
   * PlayerItem deleteMany
   */
  export type PlayerItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerItems to delete
     */
    where?: PlayerItemWhereInput
  }

  /**
   * PlayerItem without action
   */
  export type PlayerItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerItem
     */
    select?: PlayerItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerItemInclude<ExtArgs> | null
  }


  /**
   * Model Minigame
   */

  export type AggregateMinigame = {
    _count: MinigameCountAggregateOutputType | null
    _avg: MinigameAvgAggregateOutputType | null
    _sum: MinigameSumAggregateOutputType | null
    _min: MinigameMinAggregateOutputType | null
    _max: MinigameMaxAggregateOutputType | null
  }

  export type MinigameAvgAggregateOutputType = {
    difficulty: number | null
  }

  export type MinigameSumAggregateOutputType = {
    difficulty: number | null
  }

  export type MinigameMinAggregateOutputType = {
    id: string | null
    classId: string | null
    name: string | null
    description: string | null
    difficulty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MinigameMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    name: string | null
    description: string | null
    difficulty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MinigameCountAggregateOutputType = {
    id: number
    classId: number
    name: number
    description: number
    difficulty: number
    maskModifiers: number
    rewards: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MinigameAvgAggregateInputType = {
    difficulty?: true
  }

  export type MinigameSumAggregateInputType = {
    difficulty?: true
  }

  export type MinigameMinAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    difficulty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MinigameMaxAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    difficulty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MinigameCountAggregateInputType = {
    id?: true
    classId?: true
    name?: true
    description?: true
    difficulty?: true
    maskModifiers?: true
    rewards?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MinigameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Minigame to aggregate.
     */
    where?: MinigameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Minigames to fetch.
     */
    orderBy?: MinigameOrderByWithRelationInput | MinigameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MinigameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Minigames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Minigames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Minigames
    **/
    _count?: true | MinigameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MinigameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MinigameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinigameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinigameMaxAggregateInputType
  }

  export type GetMinigameAggregateType<T extends MinigameAggregateArgs> = {
        [P in keyof T & keyof AggregateMinigame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinigame[P]>
      : GetScalarType<T[P], AggregateMinigame[P]>
  }




  export type MinigameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MinigameWhereInput
    orderBy?: MinigameOrderByWithAggregationInput | MinigameOrderByWithAggregationInput[]
    by: MinigameScalarFieldEnum[] | MinigameScalarFieldEnum
    having?: MinigameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinigameCountAggregateInputType | true
    _avg?: MinigameAvgAggregateInputType
    _sum?: MinigameSumAggregateInputType
    _min?: MinigameMinAggregateInputType
    _max?: MinigameMaxAggregateInputType
  }

  export type MinigameGroupByOutputType = {
    id: string
    classId: string
    name: string
    description: string
    difficulty: number
    maskModifiers: JsonValue
    rewards: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: MinigameCountAggregateOutputType | null
    _avg: MinigameAvgAggregateOutputType | null
    _sum: MinigameSumAggregateOutputType | null
    _min: MinigameMinAggregateOutputType | null
    _max: MinigameMaxAggregateOutputType | null
  }

  type GetMinigameGroupByPayload<T extends MinigameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinigameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinigameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinigameGroupByOutputType[P]>
            : GetScalarType<T[P], MinigameGroupByOutputType[P]>
        }
      >
    >


  export type MinigameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    maskModifiers?: boolean
    rewards?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    playerProgress?: boolean | Minigame$playerProgressArgs<ExtArgs>
    _count?: boolean | MinigameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minigame"]>

  export type MinigameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    maskModifiers?: boolean
    rewards?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["minigame"]>

  export type MinigameSelectScalar = {
    id?: boolean
    classId?: boolean
    name?: boolean
    description?: boolean
    difficulty?: boolean
    maskModifiers?: boolean
    rewards?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MinigameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    playerProgress?: boolean | Minigame$playerProgressArgs<ExtArgs>
    _count?: boolean | MinigameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MinigameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MinigamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Minigame"
    objects: {
      playerProgress: Prisma.$PlayerMinigamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      name: string
      description: string
      difficulty: number
      maskModifiers: Prisma.JsonValue
      rewards: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["minigame"]>
    composites: {}
  }

  type MinigameGetPayload<S extends boolean | null | undefined | MinigameDefaultArgs> = $Result.GetResult<Prisma.$MinigamePayload, S>

  type MinigameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MinigameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MinigameCountAggregateInputType | true
    }

  export interface MinigameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Minigame'], meta: { name: 'Minigame' } }
    /**
     * Find zero or one Minigame that matches the filter.
     * @param {MinigameFindUniqueArgs} args - Arguments to find a Minigame
     * @example
     * // Get one Minigame
     * const minigame = await prisma.minigame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MinigameFindUniqueArgs>(args: SelectSubset<T, MinigameFindUniqueArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Minigame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MinigameFindUniqueOrThrowArgs} args - Arguments to find a Minigame
     * @example
     * // Get one Minigame
     * const minigame = await prisma.minigame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MinigameFindUniqueOrThrowArgs>(args: SelectSubset<T, MinigameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Minigame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinigameFindFirstArgs} args - Arguments to find a Minigame
     * @example
     * // Get one Minigame
     * const minigame = await prisma.minigame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MinigameFindFirstArgs>(args?: SelectSubset<T, MinigameFindFirstArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Minigame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinigameFindFirstOrThrowArgs} args - Arguments to find a Minigame
     * @example
     * // Get one Minigame
     * const minigame = await prisma.minigame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MinigameFindFirstOrThrowArgs>(args?: SelectSubset<T, MinigameFindFirstOrThrowArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Minigames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinigameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Minigames
     * const minigames = await prisma.minigame.findMany()
     * 
     * // Get first 10 Minigames
     * const minigames = await prisma.minigame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const minigameWithIdOnly = await prisma.minigame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MinigameFindManyArgs>(args?: SelectSubset<T, MinigameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Minigame.
     * @param {MinigameCreateArgs} args - Arguments to create a Minigame.
     * @example
     * // Create one Minigame
     * const Minigame = await prisma.minigame.create({
     *   data: {
     *     // ... data to create a Minigame
     *   }
     * })
     * 
     */
    create<T extends MinigameCreateArgs>(args: SelectSubset<T, MinigameCreateArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Minigames.
     * @param {MinigameCreateManyArgs} args - Arguments to create many Minigames.
     * @example
     * // Create many Minigames
     * const minigame = await prisma.minigame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MinigameCreateManyArgs>(args?: SelectSubset<T, MinigameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Minigames and returns the data saved in the database.
     * @param {MinigameCreateManyAndReturnArgs} args - Arguments to create many Minigames.
     * @example
     * // Create many Minigames
     * const minigame = await prisma.minigame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Minigames and only return the `id`
     * const minigameWithIdOnly = await prisma.minigame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MinigameCreateManyAndReturnArgs>(args?: SelectSubset<T, MinigameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Minigame.
     * @param {MinigameDeleteArgs} args - Arguments to delete one Minigame.
     * @example
     * // Delete one Minigame
     * const Minigame = await prisma.minigame.delete({
     *   where: {
     *     // ... filter to delete one Minigame
     *   }
     * })
     * 
     */
    delete<T extends MinigameDeleteArgs>(args: SelectSubset<T, MinigameDeleteArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Minigame.
     * @param {MinigameUpdateArgs} args - Arguments to update one Minigame.
     * @example
     * // Update one Minigame
     * const minigame = await prisma.minigame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MinigameUpdateArgs>(args: SelectSubset<T, MinigameUpdateArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Minigames.
     * @param {MinigameDeleteManyArgs} args - Arguments to filter Minigames to delete.
     * @example
     * // Delete a few Minigames
     * const { count } = await prisma.minigame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MinigameDeleteManyArgs>(args?: SelectSubset<T, MinigameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Minigames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinigameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Minigames
     * const minigame = await prisma.minigame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MinigameUpdateManyArgs>(args: SelectSubset<T, MinigameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Minigame.
     * @param {MinigameUpsertArgs} args - Arguments to update or create a Minigame.
     * @example
     * // Update or create a Minigame
     * const minigame = await prisma.minigame.upsert({
     *   create: {
     *     // ... data to create a Minigame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Minigame we want to update
     *   }
     * })
     */
    upsert<T extends MinigameUpsertArgs>(args: SelectSubset<T, MinigameUpsertArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Minigames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinigameCountArgs} args - Arguments to filter Minigames to count.
     * @example
     * // Count the number of Minigames
     * const count = await prisma.minigame.count({
     *   where: {
     *     // ... the filter for the Minigames we want to count
     *   }
     * })
    **/
    count<T extends MinigameCountArgs>(
      args?: Subset<T, MinigameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinigameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Minigame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinigameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinigameAggregateArgs>(args: Subset<T, MinigameAggregateArgs>): Prisma.PrismaPromise<GetMinigameAggregateType<T>>

    /**
     * Group by Minigame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinigameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MinigameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MinigameGroupByArgs['orderBy'] }
        : { orderBy?: MinigameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MinigameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinigameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Minigame model
   */
  readonly fields: MinigameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Minigame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MinigameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    playerProgress<T extends Minigame$playerProgressArgs<ExtArgs> = {}>(args?: Subset<T, Minigame$playerProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Minigame model
   */ 
  interface MinigameFieldRefs {
    readonly id: FieldRef<"Minigame", 'String'>
    readonly classId: FieldRef<"Minigame", 'String'>
    readonly name: FieldRef<"Minigame", 'String'>
    readonly description: FieldRef<"Minigame", 'String'>
    readonly difficulty: FieldRef<"Minigame", 'Int'>
    readonly maskModifiers: FieldRef<"Minigame", 'Json'>
    readonly rewards: FieldRef<"Minigame", 'Json'>
    readonly createdAt: FieldRef<"Minigame", 'DateTime'>
    readonly updatedAt: FieldRef<"Minigame", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Minigame findUnique
   */
  export type MinigameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * Filter, which Minigame to fetch.
     */
    where: MinigameWhereUniqueInput
  }

  /**
   * Minigame findUniqueOrThrow
   */
  export type MinigameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * Filter, which Minigame to fetch.
     */
    where: MinigameWhereUniqueInput
  }

  /**
   * Minigame findFirst
   */
  export type MinigameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * Filter, which Minigame to fetch.
     */
    where?: MinigameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Minigames to fetch.
     */
    orderBy?: MinigameOrderByWithRelationInput | MinigameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Minigames.
     */
    cursor?: MinigameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Minigames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Minigames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Minigames.
     */
    distinct?: MinigameScalarFieldEnum | MinigameScalarFieldEnum[]
  }

  /**
   * Minigame findFirstOrThrow
   */
  export type MinigameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * Filter, which Minigame to fetch.
     */
    where?: MinigameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Minigames to fetch.
     */
    orderBy?: MinigameOrderByWithRelationInput | MinigameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Minigames.
     */
    cursor?: MinigameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Minigames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Minigames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Minigames.
     */
    distinct?: MinigameScalarFieldEnum | MinigameScalarFieldEnum[]
  }

  /**
   * Minigame findMany
   */
  export type MinigameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * Filter, which Minigames to fetch.
     */
    where?: MinigameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Minigames to fetch.
     */
    orderBy?: MinigameOrderByWithRelationInput | MinigameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Minigames.
     */
    cursor?: MinigameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Minigames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Minigames.
     */
    skip?: number
    distinct?: MinigameScalarFieldEnum | MinigameScalarFieldEnum[]
  }

  /**
   * Minigame create
   */
  export type MinigameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * The data needed to create a Minigame.
     */
    data: XOR<MinigameCreateInput, MinigameUncheckedCreateInput>
  }

  /**
   * Minigame createMany
   */
  export type MinigameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Minigames.
     */
    data: MinigameCreateManyInput | MinigameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Minigame createManyAndReturn
   */
  export type MinigameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Minigames.
     */
    data: MinigameCreateManyInput | MinigameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Minigame update
   */
  export type MinigameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * The data needed to update a Minigame.
     */
    data: XOR<MinigameUpdateInput, MinigameUncheckedUpdateInput>
    /**
     * Choose, which Minigame to update.
     */
    where: MinigameWhereUniqueInput
  }

  /**
   * Minigame updateMany
   */
  export type MinigameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Minigames.
     */
    data: XOR<MinigameUpdateManyMutationInput, MinigameUncheckedUpdateManyInput>
    /**
     * Filter which Minigames to update
     */
    where?: MinigameWhereInput
  }

  /**
   * Minigame upsert
   */
  export type MinigameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * The filter to search for the Minigame to update in case it exists.
     */
    where: MinigameWhereUniqueInput
    /**
     * In case the Minigame found by the `where` argument doesn't exist, create a new Minigame with this data.
     */
    create: XOR<MinigameCreateInput, MinigameUncheckedCreateInput>
    /**
     * In case the Minigame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MinigameUpdateInput, MinigameUncheckedUpdateInput>
  }

  /**
   * Minigame delete
   */
  export type MinigameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
    /**
     * Filter which Minigame to delete.
     */
    where: MinigameWhereUniqueInput
  }

  /**
   * Minigame deleteMany
   */
  export type MinigameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Minigames to delete
     */
    where?: MinigameWhereInput
  }

  /**
   * Minigame.playerProgress
   */
  export type Minigame$playerProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    where?: PlayerMinigameWhereInput
    orderBy?: PlayerMinigameOrderByWithRelationInput | PlayerMinigameOrderByWithRelationInput[]
    cursor?: PlayerMinigameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerMinigameScalarFieldEnum | PlayerMinigameScalarFieldEnum[]
  }

  /**
   * Minigame without action
   */
  export type MinigameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Minigame
     */
    select?: MinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MinigameInclude<ExtArgs> | null
  }


  /**
   * Model PlayerMinigame
   */

  export type AggregatePlayerMinigame = {
    _count: PlayerMinigameCountAggregateOutputType | null
    _avg: PlayerMinigameAvgAggregateOutputType | null
    _sum: PlayerMinigameSumAggregateOutputType | null
    _min: PlayerMinigameMinAggregateOutputType | null
    _max: PlayerMinigameMaxAggregateOutputType | null
  }

  export type PlayerMinigameAvgAggregateOutputType = {
    score: number | null
  }

  export type PlayerMinigameSumAggregateOutputType = {
    score: number | null
  }

  export type PlayerMinigameMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    minigameId: string | null
    score: number | null
    completed: boolean | null
  }

  export type PlayerMinigameMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    minigameId: string | null
    score: number | null
    completed: boolean | null
  }

  export type PlayerMinigameCountAggregateOutputType = {
    id: number
    playerId: number
    minigameId: number
    score: number
    completed: number
    _all: number
  }


  export type PlayerMinigameAvgAggregateInputType = {
    score?: true
  }

  export type PlayerMinigameSumAggregateInputType = {
    score?: true
  }

  export type PlayerMinigameMinAggregateInputType = {
    id?: true
    playerId?: true
    minigameId?: true
    score?: true
    completed?: true
  }

  export type PlayerMinigameMaxAggregateInputType = {
    id?: true
    playerId?: true
    minigameId?: true
    score?: true
    completed?: true
  }

  export type PlayerMinigameCountAggregateInputType = {
    id?: true
    playerId?: true
    minigameId?: true
    score?: true
    completed?: true
    _all?: true
  }

  export type PlayerMinigameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerMinigame to aggregate.
     */
    where?: PlayerMinigameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMinigames to fetch.
     */
    orderBy?: PlayerMinigameOrderByWithRelationInput | PlayerMinigameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerMinigameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMinigames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMinigames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerMinigames
    **/
    _count?: true | PlayerMinigameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerMinigameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerMinigameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinigameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMinigameMaxAggregateInputType
  }

  export type GetPlayerMinigameAggregateType<T extends PlayerMinigameAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerMinigame]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerMinigame[P]>
      : GetScalarType<T[P], AggregatePlayerMinigame[P]>
  }




  export type PlayerMinigameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerMinigameWhereInput
    orderBy?: PlayerMinigameOrderByWithAggregationInput | PlayerMinigameOrderByWithAggregationInput[]
    by: PlayerMinigameScalarFieldEnum[] | PlayerMinigameScalarFieldEnum
    having?: PlayerMinigameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerMinigameCountAggregateInputType | true
    _avg?: PlayerMinigameAvgAggregateInputType
    _sum?: PlayerMinigameSumAggregateInputType
    _min?: PlayerMinigameMinAggregateInputType
    _max?: PlayerMinigameMaxAggregateInputType
  }

  export type PlayerMinigameGroupByOutputType = {
    id: string
    playerId: string
    minigameId: string
    score: number
    completed: boolean
    _count: PlayerMinigameCountAggregateOutputType | null
    _avg: PlayerMinigameAvgAggregateOutputType | null
    _sum: PlayerMinigameSumAggregateOutputType | null
    _min: PlayerMinigameMinAggregateOutputType | null
    _max: PlayerMinigameMaxAggregateOutputType | null
  }

  type GetPlayerMinigameGroupByPayload<T extends PlayerMinigameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerMinigameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerMinigameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerMinigameGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerMinigameGroupByOutputType[P]>
        }
      >
    >


  export type PlayerMinigameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    minigameId?: boolean
    score?: boolean
    completed?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    minigame?: boolean | MinigameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerMinigame"]>

  export type PlayerMinigameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    minigameId?: boolean
    score?: boolean
    completed?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    minigame?: boolean | MinigameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerMinigame"]>

  export type PlayerMinigameSelectScalar = {
    id?: boolean
    playerId?: boolean
    minigameId?: boolean
    score?: boolean
    completed?: boolean
  }

  export type PlayerMinigameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    minigame?: boolean | MinigameDefaultArgs<ExtArgs>
  }
  export type PlayerMinigameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    minigame?: boolean | MinigameDefaultArgs<ExtArgs>
  }

  export type $PlayerMinigamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerMinigame"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      minigame: Prisma.$MinigamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      minigameId: string
      score: number
      completed: boolean
    }, ExtArgs["result"]["playerMinigame"]>
    composites: {}
  }

  type PlayerMinigameGetPayload<S extends boolean | null | undefined | PlayerMinigameDefaultArgs> = $Result.GetResult<Prisma.$PlayerMinigamePayload, S>

  type PlayerMinigameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerMinigameFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerMinigameCountAggregateInputType | true
    }

  export interface PlayerMinigameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerMinigame'], meta: { name: 'PlayerMinigame' } }
    /**
     * Find zero or one PlayerMinigame that matches the filter.
     * @param {PlayerMinigameFindUniqueArgs} args - Arguments to find a PlayerMinigame
     * @example
     * // Get one PlayerMinigame
     * const playerMinigame = await prisma.playerMinigame.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerMinigameFindUniqueArgs>(args: SelectSubset<T, PlayerMinigameFindUniqueArgs<ExtArgs>>): Prisma__PlayerMinigameClient<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerMinigame that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerMinigameFindUniqueOrThrowArgs} args - Arguments to find a PlayerMinigame
     * @example
     * // Get one PlayerMinigame
     * const playerMinigame = await prisma.playerMinigame.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerMinigameFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerMinigameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerMinigameClient<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerMinigame that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMinigameFindFirstArgs} args - Arguments to find a PlayerMinigame
     * @example
     * // Get one PlayerMinigame
     * const playerMinigame = await prisma.playerMinigame.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerMinigameFindFirstArgs>(args?: SelectSubset<T, PlayerMinigameFindFirstArgs<ExtArgs>>): Prisma__PlayerMinigameClient<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerMinigame that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMinigameFindFirstOrThrowArgs} args - Arguments to find a PlayerMinigame
     * @example
     * // Get one PlayerMinigame
     * const playerMinigame = await prisma.playerMinigame.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerMinigameFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerMinigameFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerMinigameClient<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerMinigames that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMinigameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerMinigames
     * const playerMinigames = await prisma.playerMinigame.findMany()
     * 
     * // Get first 10 PlayerMinigames
     * const playerMinigames = await prisma.playerMinigame.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerMinigameWithIdOnly = await prisma.playerMinigame.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerMinigameFindManyArgs>(args?: SelectSubset<T, PlayerMinigameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerMinigame.
     * @param {PlayerMinigameCreateArgs} args - Arguments to create a PlayerMinigame.
     * @example
     * // Create one PlayerMinigame
     * const PlayerMinigame = await prisma.playerMinigame.create({
     *   data: {
     *     // ... data to create a PlayerMinigame
     *   }
     * })
     * 
     */
    create<T extends PlayerMinigameCreateArgs>(args: SelectSubset<T, PlayerMinigameCreateArgs<ExtArgs>>): Prisma__PlayerMinigameClient<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerMinigames.
     * @param {PlayerMinigameCreateManyArgs} args - Arguments to create many PlayerMinigames.
     * @example
     * // Create many PlayerMinigames
     * const playerMinigame = await prisma.playerMinigame.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerMinigameCreateManyArgs>(args?: SelectSubset<T, PlayerMinigameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerMinigames and returns the data saved in the database.
     * @param {PlayerMinigameCreateManyAndReturnArgs} args - Arguments to create many PlayerMinigames.
     * @example
     * // Create many PlayerMinigames
     * const playerMinigame = await prisma.playerMinigame.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerMinigames and only return the `id`
     * const playerMinigameWithIdOnly = await prisma.playerMinigame.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerMinigameCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerMinigameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerMinigame.
     * @param {PlayerMinigameDeleteArgs} args - Arguments to delete one PlayerMinigame.
     * @example
     * // Delete one PlayerMinigame
     * const PlayerMinigame = await prisma.playerMinigame.delete({
     *   where: {
     *     // ... filter to delete one PlayerMinigame
     *   }
     * })
     * 
     */
    delete<T extends PlayerMinigameDeleteArgs>(args: SelectSubset<T, PlayerMinigameDeleteArgs<ExtArgs>>): Prisma__PlayerMinigameClient<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerMinigame.
     * @param {PlayerMinigameUpdateArgs} args - Arguments to update one PlayerMinigame.
     * @example
     * // Update one PlayerMinigame
     * const playerMinigame = await prisma.playerMinigame.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerMinigameUpdateArgs>(args: SelectSubset<T, PlayerMinigameUpdateArgs<ExtArgs>>): Prisma__PlayerMinigameClient<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerMinigames.
     * @param {PlayerMinigameDeleteManyArgs} args - Arguments to filter PlayerMinigames to delete.
     * @example
     * // Delete a few PlayerMinigames
     * const { count } = await prisma.playerMinigame.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerMinigameDeleteManyArgs>(args?: SelectSubset<T, PlayerMinigameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerMinigames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMinigameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerMinigames
     * const playerMinigame = await prisma.playerMinigame.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerMinigameUpdateManyArgs>(args: SelectSubset<T, PlayerMinigameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerMinigame.
     * @param {PlayerMinigameUpsertArgs} args - Arguments to update or create a PlayerMinigame.
     * @example
     * // Update or create a PlayerMinigame
     * const playerMinigame = await prisma.playerMinigame.upsert({
     *   create: {
     *     // ... data to create a PlayerMinigame
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerMinigame we want to update
     *   }
     * })
     */
    upsert<T extends PlayerMinigameUpsertArgs>(args: SelectSubset<T, PlayerMinigameUpsertArgs<ExtArgs>>): Prisma__PlayerMinigameClient<$Result.GetResult<Prisma.$PlayerMinigamePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerMinigames.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMinigameCountArgs} args - Arguments to filter PlayerMinigames to count.
     * @example
     * // Count the number of PlayerMinigames
     * const count = await prisma.playerMinigame.count({
     *   where: {
     *     // ... the filter for the PlayerMinigames we want to count
     *   }
     * })
    **/
    count<T extends PlayerMinigameCountArgs>(
      args?: Subset<T, PlayerMinigameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerMinigameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerMinigame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMinigameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerMinigameAggregateArgs>(args: Subset<T, PlayerMinigameAggregateArgs>): Prisma.PrismaPromise<GetPlayerMinigameAggregateType<T>>

    /**
     * Group by PlayerMinigame.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerMinigameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerMinigameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerMinigameGroupByArgs['orderBy'] }
        : { orderBy?: PlayerMinigameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerMinigameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerMinigameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerMinigame model
   */
  readonly fields: PlayerMinigameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerMinigame.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerMinigameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    minigame<T extends MinigameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MinigameDefaultArgs<ExtArgs>>): Prisma__MinigameClient<$Result.GetResult<Prisma.$MinigamePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerMinigame model
   */ 
  interface PlayerMinigameFieldRefs {
    readonly id: FieldRef<"PlayerMinigame", 'String'>
    readonly playerId: FieldRef<"PlayerMinigame", 'String'>
    readonly minigameId: FieldRef<"PlayerMinigame", 'String'>
    readonly score: FieldRef<"PlayerMinigame", 'Int'>
    readonly completed: FieldRef<"PlayerMinigame", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PlayerMinigame findUnique
   */
  export type PlayerMinigameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMinigame to fetch.
     */
    where: PlayerMinigameWhereUniqueInput
  }

  /**
   * PlayerMinigame findUniqueOrThrow
   */
  export type PlayerMinigameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMinigame to fetch.
     */
    where: PlayerMinigameWhereUniqueInput
  }

  /**
   * PlayerMinigame findFirst
   */
  export type PlayerMinigameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMinigame to fetch.
     */
    where?: PlayerMinigameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMinigames to fetch.
     */
    orderBy?: PlayerMinigameOrderByWithRelationInput | PlayerMinigameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerMinigames.
     */
    cursor?: PlayerMinigameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMinigames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMinigames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerMinigames.
     */
    distinct?: PlayerMinigameScalarFieldEnum | PlayerMinigameScalarFieldEnum[]
  }

  /**
   * PlayerMinigame findFirstOrThrow
   */
  export type PlayerMinigameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMinigame to fetch.
     */
    where?: PlayerMinigameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMinigames to fetch.
     */
    orderBy?: PlayerMinigameOrderByWithRelationInput | PlayerMinigameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerMinigames.
     */
    cursor?: PlayerMinigameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMinigames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMinigames.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerMinigames.
     */
    distinct?: PlayerMinigameScalarFieldEnum | PlayerMinigameScalarFieldEnum[]
  }

  /**
   * PlayerMinigame findMany
   */
  export type PlayerMinigameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * Filter, which PlayerMinigames to fetch.
     */
    where?: PlayerMinigameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerMinigames to fetch.
     */
    orderBy?: PlayerMinigameOrderByWithRelationInput | PlayerMinigameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerMinigames.
     */
    cursor?: PlayerMinigameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerMinigames from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerMinigames.
     */
    skip?: number
    distinct?: PlayerMinigameScalarFieldEnum | PlayerMinigameScalarFieldEnum[]
  }

  /**
   * PlayerMinigame create
   */
  export type PlayerMinigameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerMinigame.
     */
    data: XOR<PlayerMinigameCreateInput, PlayerMinigameUncheckedCreateInput>
  }

  /**
   * PlayerMinigame createMany
   */
  export type PlayerMinigameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerMinigames.
     */
    data: PlayerMinigameCreateManyInput | PlayerMinigameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerMinigame createManyAndReturn
   */
  export type PlayerMinigameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerMinigames.
     */
    data: PlayerMinigameCreateManyInput | PlayerMinigameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerMinigame update
   */
  export type PlayerMinigameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerMinigame.
     */
    data: XOR<PlayerMinigameUpdateInput, PlayerMinigameUncheckedUpdateInput>
    /**
     * Choose, which PlayerMinigame to update.
     */
    where: PlayerMinigameWhereUniqueInput
  }

  /**
   * PlayerMinigame updateMany
   */
  export type PlayerMinigameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerMinigames.
     */
    data: XOR<PlayerMinigameUpdateManyMutationInput, PlayerMinigameUncheckedUpdateManyInput>
    /**
     * Filter which PlayerMinigames to update
     */
    where?: PlayerMinigameWhereInput
  }

  /**
   * PlayerMinigame upsert
   */
  export type PlayerMinigameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerMinigame to update in case it exists.
     */
    where: PlayerMinigameWhereUniqueInput
    /**
     * In case the PlayerMinigame found by the `where` argument doesn't exist, create a new PlayerMinigame with this data.
     */
    create: XOR<PlayerMinigameCreateInput, PlayerMinigameUncheckedCreateInput>
    /**
     * In case the PlayerMinigame was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerMinigameUpdateInput, PlayerMinigameUncheckedUpdateInput>
  }

  /**
   * PlayerMinigame delete
   */
  export type PlayerMinigameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
    /**
     * Filter which PlayerMinigame to delete.
     */
    where: PlayerMinigameWhereUniqueInput
  }

  /**
   * PlayerMinigame deleteMany
   */
  export type PlayerMinigameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerMinigames to delete
     */
    where?: PlayerMinigameWhereInput
  }

  /**
   * PlayerMinigame without action
   */
  export type PlayerMinigameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerMinigame
     */
    select?: PlayerMinigameSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerMinigameInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    triggerChance: number | null
  }

  export type EventSumAggregateOutputType = {
    triggerChance: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    name: string | null
    triggerChance: number | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    name: string | null
    triggerChance: number | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    name: number
    triggerChance: number
    triggerZones: number
    maskModifiers: number
    choices: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    triggerChance?: true
  }

  export type EventSumAggregateInputType = {
    triggerChance?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    name?: true
    triggerChance?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    name?: true
    triggerChance?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    name?: true
    triggerChance?: true
    triggerZones?: true
    maskModifiers?: true
    choices?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    name: string
    triggerChance: number
    triggerZones: string[]
    maskModifiers: JsonValue
    choices: JsonValue
    zoneId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    triggerChance?: boolean
    triggerZones?: boolean
    maskModifiers?: boolean
    choices?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | Event$zoneArgs<ExtArgs>
    players?: boolean | Event$playersArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    triggerChance?: boolean
    triggerZones?: boolean
    maskModifiers?: boolean
    choices?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | Event$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    name?: boolean
    triggerChance?: boolean
    triggerZones?: boolean
    maskModifiers?: boolean
    choices?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | Event$zoneArgs<ExtArgs>
    players?: boolean | Event$playersArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | Event$zoneArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs> | null
      players: Prisma.$PlayerEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      triggerChance: number
      triggerZones: string[]
      maskModifiers: Prisma.JsonValue
      choices: Prisma.JsonValue
      zoneId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends Event$zoneArgs<ExtArgs> = {}>(args?: Subset<T, Event$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    players<T extends Event$playersArgs<ExtArgs> = {}>(args?: Subset<T, Event$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly name: FieldRef<"Event", 'String'>
    readonly triggerChance: FieldRef<"Event", 'Int'>
    readonly triggerZones: FieldRef<"Event", 'String[]'>
    readonly maskModifiers: FieldRef<"Event", 'Json'>
    readonly choices: FieldRef<"Event", 'Json'>
    readonly zoneId: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.zone
   */
  export type Event$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * Event.players
   */
  export type Event$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    where?: PlayerEventWhereInput
    orderBy?: PlayerEventOrderByWithRelationInput | PlayerEventOrderByWithRelationInput[]
    cursor?: PlayerEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerEventScalarFieldEnum | PlayerEventScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model PlayerEvent
   */

  export type AggregatePlayerEvent = {
    _count: PlayerEventCountAggregateOutputType | null
    _min: PlayerEventMinAggregateOutputType | null
    _max: PlayerEventMaxAggregateOutputType | null
  }

  export type PlayerEventMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    eventId: string | null
    choiceMade: string | null
    completed: boolean | null
  }

  export type PlayerEventMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    eventId: string | null
    choiceMade: string | null
    completed: boolean | null
  }

  export type PlayerEventCountAggregateOutputType = {
    id: number
    playerId: number
    eventId: number
    choiceMade: number
    completed: number
    _all: number
  }


  export type PlayerEventMinAggregateInputType = {
    id?: true
    playerId?: true
    eventId?: true
    choiceMade?: true
    completed?: true
  }

  export type PlayerEventMaxAggregateInputType = {
    id?: true
    playerId?: true
    eventId?: true
    choiceMade?: true
    completed?: true
  }

  export type PlayerEventCountAggregateInputType = {
    id?: true
    playerId?: true
    eventId?: true
    choiceMade?: true
    completed?: true
    _all?: true
  }

  export type PlayerEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerEvent to aggregate.
     */
    where?: PlayerEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEvents to fetch.
     */
    orderBy?: PlayerEventOrderByWithRelationInput | PlayerEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerEvents
    **/
    _count?: true | PlayerEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerEventMaxAggregateInputType
  }

  export type GetPlayerEventAggregateType<T extends PlayerEventAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerEvent[P]>
      : GetScalarType<T[P], AggregatePlayerEvent[P]>
  }




  export type PlayerEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerEventWhereInput
    orderBy?: PlayerEventOrderByWithAggregationInput | PlayerEventOrderByWithAggregationInput[]
    by: PlayerEventScalarFieldEnum[] | PlayerEventScalarFieldEnum
    having?: PlayerEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerEventCountAggregateInputType | true
    _min?: PlayerEventMinAggregateInputType
    _max?: PlayerEventMaxAggregateInputType
  }

  export type PlayerEventGroupByOutputType = {
    id: string
    playerId: string
    eventId: string
    choiceMade: string | null
    completed: boolean
    _count: PlayerEventCountAggregateOutputType | null
    _min: PlayerEventMinAggregateOutputType | null
    _max: PlayerEventMaxAggregateOutputType | null
  }

  type GetPlayerEventGroupByPayload<T extends PlayerEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerEventGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerEventGroupByOutputType[P]>
        }
      >
    >


  export type PlayerEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    eventId?: boolean
    choiceMade?: boolean
    completed?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerEvent"]>

  export type PlayerEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    eventId?: boolean
    choiceMade?: boolean
    completed?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerEvent"]>

  export type PlayerEventSelectScalar = {
    id?: boolean
    playerId?: boolean
    eventId?: boolean
    choiceMade?: boolean
    completed?: boolean
  }

  export type PlayerEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type PlayerEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $PlayerEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerEvent"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      event: Prisma.$EventPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      eventId: string
      choiceMade: string | null
      completed: boolean
    }, ExtArgs["result"]["playerEvent"]>
    composites: {}
  }

  type PlayerEventGetPayload<S extends boolean | null | undefined | PlayerEventDefaultArgs> = $Result.GetResult<Prisma.$PlayerEventPayload, S>

  type PlayerEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerEventCountAggregateInputType | true
    }

  export interface PlayerEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerEvent'], meta: { name: 'PlayerEvent' } }
    /**
     * Find zero or one PlayerEvent that matches the filter.
     * @param {PlayerEventFindUniqueArgs} args - Arguments to find a PlayerEvent
     * @example
     * // Get one PlayerEvent
     * const playerEvent = await prisma.playerEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerEventFindUniqueArgs>(args: SelectSubset<T, PlayerEventFindUniqueArgs<ExtArgs>>): Prisma__PlayerEventClient<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerEventFindUniqueOrThrowArgs} args - Arguments to find a PlayerEvent
     * @example
     * // Get one PlayerEvent
     * const playerEvent = await prisma.playerEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerEventFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerEventClient<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEventFindFirstArgs} args - Arguments to find a PlayerEvent
     * @example
     * // Get one PlayerEvent
     * const playerEvent = await prisma.playerEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerEventFindFirstArgs>(args?: SelectSubset<T, PlayerEventFindFirstArgs<ExtArgs>>): Prisma__PlayerEventClient<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEventFindFirstOrThrowArgs} args - Arguments to find a PlayerEvent
     * @example
     * // Get one PlayerEvent
     * const playerEvent = await prisma.playerEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerEventFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerEventClient<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerEvents
     * const playerEvents = await prisma.playerEvent.findMany()
     * 
     * // Get first 10 PlayerEvents
     * const playerEvents = await prisma.playerEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerEventWithIdOnly = await prisma.playerEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerEventFindManyArgs>(args?: SelectSubset<T, PlayerEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerEvent.
     * @param {PlayerEventCreateArgs} args - Arguments to create a PlayerEvent.
     * @example
     * // Create one PlayerEvent
     * const PlayerEvent = await prisma.playerEvent.create({
     *   data: {
     *     // ... data to create a PlayerEvent
     *   }
     * })
     * 
     */
    create<T extends PlayerEventCreateArgs>(args: SelectSubset<T, PlayerEventCreateArgs<ExtArgs>>): Prisma__PlayerEventClient<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerEvents.
     * @param {PlayerEventCreateManyArgs} args - Arguments to create many PlayerEvents.
     * @example
     * // Create many PlayerEvents
     * const playerEvent = await prisma.playerEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerEventCreateManyArgs>(args?: SelectSubset<T, PlayerEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerEvents and returns the data saved in the database.
     * @param {PlayerEventCreateManyAndReturnArgs} args - Arguments to create many PlayerEvents.
     * @example
     * // Create many PlayerEvents
     * const playerEvent = await prisma.playerEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerEvents and only return the `id`
     * const playerEventWithIdOnly = await prisma.playerEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerEventCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerEvent.
     * @param {PlayerEventDeleteArgs} args - Arguments to delete one PlayerEvent.
     * @example
     * // Delete one PlayerEvent
     * const PlayerEvent = await prisma.playerEvent.delete({
     *   where: {
     *     // ... filter to delete one PlayerEvent
     *   }
     * })
     * 
     */
    delete<T extends PlayerEventDeleteArgs>(args: SelectSubset<T, PlayerEventDeleteArgs<ExtArgs>>): Prisma__PlayerEventClient<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerEvent.
     * @param {PlayerEventUpdateArgs} args - Arguments to update one PlayerEvent.
     * @example
     * // Update one PlayerEvent
     * const playerEvent = await prisma.playerEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerEventUpdateArgs>(args: SelectSubset<T, PlayerEventUpdateArgs<ExtArgs>>): Prisma__PlayerEventClient<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerEvents.
     * @param {PlayerEventDeleteManyArgs} args - Arguments to filter PlayerEvents to delete.
     * @example
     * // Delete a few PlayerEvents
     * const { count } = await prisma.playerEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerEventDeleteManyArgs>(args?: SelectSubset<T, PlayerEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerEvents
     * const playerEvent = await prisma.playerEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerEventUpdateManyArgs>(args: SelectSubset<T, PlayerEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerEvent.
     * @param {PlayerEventUpsertArgs} args - Arguments to update or create a PlayerEvent.
     * @example
     * // Update or create a PlayerEvent
     * const playerEvent = await prisma.playerEvent.upsert({
     *   create: {
     *     // ... data to create a PlayerEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerEvent we want to update
     *   }
     * })
     */
    upsert<T extends PlayerEventUpsertArgs>(args: SelectSubset<T, PlayerEventUpsertArgs<ExtArgs>>): Prisma__PlayerEventClient<$Result.GetResult<Prisma.$PlayerEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEventCountArgs} args - Arguments to filter PlayerEvents to count.
     * @example
     * // Count the number of PlayerEvents
     * const count = await prisma.playerEvent.count({
     *   where: {
     *     // ... the filter for the PlayerEvents we want to count
     *   }
     * })
    **/
    count<T extends PlayerEventCountArgs>(
      args?: Subset<T, PlayerEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerEventAggregateArgs>(args: Subset<T, PlayerEventAggregateArgs>): Prisma.PrismaPromise<GetPlayerEventAggregateType<T>>

    /**
     * Group by PlayerEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerEventGroupByArgs['orderBy'] }
        : { orderBy?: PlayerEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerEvent model
   */
  readonly fields: PlayerEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerEvent model
   */ 
  interface PlayerEventFieldRefs {
    readonly id: FieldRef<"PlayerEvent", 'String'>
    readonly playerId: FieldRef<"PlayerEvent", 'String'>
    readonly eventId: FieldRef<"PlayerEvent", 'String'>
    readonly choiceMade: FieldRef<"PlayerEvent", 'String'>
    readonly completed: FieldRef<"PlayerEvent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PlayerEvent findUnique
   */
  export type PlayerEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEvent to fetch.
     */
    where: PlayerEventWhereUniqueInput
  }

  /**
   * PlayerEvent findUniqueOrThrow
   */
  export type PlayerEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEvent to fetch.
     */
    where: PlayerEventWhereUniqueInput
  }

  /**
   * PlayerEvent findFirst
   */
  export type PlayerEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEvent to fetch.
     */
    where?: PlayerEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEvents to fetch.
     */
    orderBy?: PlayerEventOrderByWithRelationInput | PlayerEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerEvents.
     */
    cursor?: PlayerEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerEvents.
     */
    distinct?: PlayerEventScalarFieldEnum | PlayerEventScalarFieldEnum[]
  }

  /**
   * PlayerEvent findFirstOrThrow
   */
  export type PlayerEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEvent to fetch.
     */
    where?: PlayerEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEvents to fetch.
     */
    orderBy?: PlayerEventOrderByWithRelationInput | PlayerEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerEvents.
     */
    cursor?: PlayerEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerEvents.
     */
    distinct?: PlayerEventScalarFieldEnum | PlayerEventScalarFieldEnum[]
  }

  /**
   * PlayerEvent findMany
   */
  export type PlayerEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * Filter, which PlayerEvents to fetch.
     */
    where?: PlayerEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerEvents to fetch.
     */
    orderBy?: PlayerEventOrderByWithRelationInput | PlayerEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerEvents.
     */
    cursor?: PlayerEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerEvents.
     */
    skip?: number
    distinct?: PlayerEventScalarFieldEnum | PlayerEventScalarFieldEnum[]
  }

  /**
   * PlayerEvent create
   */
  export type PlayerEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerEvent.
     */
    data: XOR<PlayerEventCreateInput, PlayerEventUncheckedCreateInput>
  }

  /**
   * PlayerEvent createMany
   */
  export type PlayerEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerEvents.
     */
    data: PlayerEventCreateManyInput | PlayerEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerEvent createManyAndReturn
   */
  export type PlayerEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerEvents.
     */
    data: PlayerEventCreateManyInput | PlayerEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerEvent update
   */
  export type PlayerEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerEvent.
     */
    data: XOR<PlayerEventUpdateInput, PlayerEventUncheckedUpdateInput>
    /**
     * Choose, which PlayerEvent to update.
     */
    where: PlayerEventWhereUniqueInput
  }

  /**
   * PlayerEvent updateMany
   */
  export type PlayerEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerEvents.
     */
    data: XOR<PlayerEventUpdateManyMutationInput, PlayerEventUncheckedUpdateManyInput>
    /**
     * Filter which PlayerEvents to update
     */
    where?: PlayerEventWhereInput
  }

  /**
   * PlayerEvent upsert
   */
  export type PlayerEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerEvent to update in case it exists.
     */
    where: PlayerEventWhereUniqueInput
    /**
     * In case the PlayerEvent found by the `where` argument doesn't exist, create a new PlayerEvent with this data.
     */
    create: XOR<PlayerEventCreateInput, PlayerEventUncheckedCreateInput>
    /**
     * In case the PlayerEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerEventUpdateInput, PlayerEventUncheckedUpdateInput>
  }

  /**
   * PlayerEvent delete
   */
  export type PlayerEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
    /**
     * Filter which PlayerEvent to delete.
     */
    where: PlayerEventWhereUniqueInput
  }

  /**
   * PlayerEvent deleteMany
   */
  export type PlayerEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerEvents to delete
     */
    where?: PlayerEventWhereInput
  }

  /**
   * PlayerEvent without action
   */
  export type PlayerEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerEvent
     */
    select?: PlayerEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerEventInclude<ExtArgs> | null
  }


  /**
   * Model Action
   */

  export type AggregateAction = {
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  export type ActionAvgAggregateOutputType = {
    timeCost: number | null
  }

  export type ActionSumAggregateOutputType = {
    timeCost: number | null
  }

  export type ActionMinAggregateOutputType = {
    id: string | null
    name: string | null
    zoneId: string | null
    timeCost: number | null
    riskLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    zoneId: string | null
    timeCost: number | null
    riskLevel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionCountAggregateOutputType = {
    id: number
    name: number
    zoneId: number
    preconditions: number
    timeCost: number
    effects: number
    riskLevel: number
    maskModifiers: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActionAvgAggregateInputType = {
    timeCost?: true
  }

  export type ActionSumAggregateInputType = {
    timeCost?: true
  }

  export type ActionMinAggregateInputType = {
    id?: true
    name?: true
    zoneId?: true
    timeCost?: true
    riskLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionMaxAggregateInputType = {
    id?: true
    name?: true
    zoneId?: true
    timeCost?: true
    riskLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionCountAggregateInputType = {
    id?: true
    name?: true
    zoneId?: true
    preconditions?: true
    timeCost?: true
    effects?: true
    riskLevel?: true
    maskModifiers?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Action to aggregate.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Actions
    **/
    _count?: true | ActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionMaxAggregateInputType
  }

  export type GetActionAggregateType<T extends ActionAggregateArgs> = {
        [P in keyof T & keyof AggregateAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAction[P]>
      : GetScalarType<T[P], AggregateAction[P]>
  }




  export type ActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionWhereInput
    orderBy?: ActionOrderByWithAggregationInput | ActionOrderByWithAggregationInput[]
    by: ActionScalarFieldEnum[] | ActionScalarFieldEnum
    having?: ActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionCountAggregateInputType | true
    _avg?: ActionAvgAggregateInputType
    _sum?: ActionSumAggregateInputType
    _min?: ActionMinAggregateInputType
    _max?: ActionMaxAggregateInputType
  }

  export type ActionGroupByOutputType = {
    id: string
    name: string
    zoneId: string | null
    preconditions: JsonValue
    timeCost: number
    effects: JsonValue
    riskLevel: string
    maskModifiers: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ActionCountAggregateOutputType | null
    _avg: ActionAvgAggregateOutputType | null
    _sum: ActionSumAggregateOutputType | null
    _min: ActionMinAggregateOutputType | null
    _max: ActionMaxAggregateOutputType | null
  }

  type GetActionGroupByPayload<T extends ActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionGroupByOutputType[P]>
            : GetScalarType<T[P], ActionGroupByOutputType[P]>
        }
      >
    >


  export type ActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    zoneId?: boolean
    preconditions?: boolean
    timeCost?: boolean
    effects?: boolean
    riskLevel?: boolean
    maskModifiers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | Action$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    zoneId?: boolean
    preconditions?: boolean
    timeCost?: boolean
    effects?: boolean
    riskLevel?: boolean
    maskModifiers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    zone?: boolean | Action$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["action"]>

  export type ActionSelectScalar = {
    id?: boolean
    name?: boolean
    zoneId?: boolean
    preconditions?: boolean
    timeCost?: boolean
    effects?: boolean
    riskLevel?: boolean
    maskModifiers?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | Action$zoneArgs<ExtArgs>
  }
  export type ActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | Action$zoneArgs<ExtArgs>
  }

  export type $ActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Action"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      zoneId: string | null
      preconditions: Prisma.JsonValue
      timeCost: number
      effects: Prisma.JsonValue
      riskLevel: string
      maskModifiers: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["action"]>
    composites: {}
  }

  type ActionGetPayload<S extends boolean | null | undefined | ActionDefaultArgs> = $Result.GetResult<Prisma.$ActionPayload, S>

  type ActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActionCountAggregateInputType | true
    }

  export interface ActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Action'], meta: { name: 'Action' } }
    /**
     * Find zero or one Action that matches the filter.
     * @param {ActionFindUniqueArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionFindUniqueArgs>(args: SelectSubset<T, ActionFindUniqueArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Action that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActionFindUniqueOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Action that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionFindFirstArgs>(args?: SelectSubset<T, ActionFindFirstArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Action that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindFirstOrThrowArgs} args - Arguments to find a Action
     * @example
     * // Get one Action
     * const action = await prisma.action.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actions
     * const actions = await prisma.action.findMany()
     * 
     * // Get first 10 Actions
     * const actions = await prisma.action.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionWithIdOnly = await prisma.action.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionFindManyArgs>(args?: SelectSubset<T, ActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Action.
     * @param {ActionCreateArgs} args - Arguments to create a Action.
     * @example
     * // Create one Action
     * const Action = await prisma.action.create({
     *   data: {
     *     // ... data to create a Action
     *   }
     * })
     * 
     */
    create<T extends ActionCreateArgs>(args: SelectSubset<T, ActionCreateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Actions.
     * @param {ActionCreateManyArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionCreateManyArgs>(args?: SelectSubset<T, ActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Actions and returns the data saved in the database.
     * @param {ActionCreateManyAndReturnArgs} args - Arguments to create many Actions.
     * @example
     * // Create many Actions
     * const action = await prisma.action.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Actions and only return the `id`
     * const actionWithIdOnly = await prisma.action.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Action.
     * @param {ActionDeleteArgs} args - Arguments to delete one Action.
     * @example
     * // Delete one Action
     * const Action = await prisma.action.delete({
     *   where: {
     *     // ... filter to delete one Action
     *   }
     * })
     * 
     */
    delete<T extends ActionDeleteArgs>(args: SelectSubset<T, ActionDeleteArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Action.
     * @param {ActionUpdateArgs} args - Arguments to update one Action.
     * @example
     * // Update one Action
     * const action = await prisma.action.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionUpdateArgs>(args: SelectSubset<T, ActionUpdateArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Actions.
     * @param {ActionDeleteManyArgs} args - Arguments to filter Actions to delete.
     * @example
     * // Delete a few Actions
     * const { count } = await prisma.action.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionDeleteManyArgs>(args?: SelectSubset<T, ActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actions
     * const action = await prisma.action.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionUpdateManyArgs>(args: SelectSubset<T, ActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Action.
     * @param {ActionUpsertArgs} args - Arguments to update or create a Action.
     * @example
     * // Update or create a Action
     * const action = await prisma.action.upsert({
     *   create: {
     *     // ... data to create a Action
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Action we want to update
     *   }
     * })
     */
    upsert<T extends ActionUpsertArgs>(args: SelectSubset<T, ActionUpsertArgs<ExtArgs>>): Prisma__ActionClient<$Result.GetResult<Prisma.$ActionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionCountArgs} args - Arguments to filter Actions to count.
     * @example
     * // Count the number of Actions
     * const count = await prisma.action.count({
     *   where: {
     *     // ... the filter for the Actions we want to count
     *   }
     * })
    **/
    count<T extends ActionCountArgs>(
      args?: Subset<T, ActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionAggregateArgs>(args: Subset<T, ActionAggregateArgs>): Prisma.PrismaPromise<GetActionAggregateType<T>>

    /**
     * Group by Action.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionGroupByArgs['orderBy'] }
        : { orderBy?: ActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Action model
   */
  readonly fields: ActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Action.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends Action$zoneArgs<ExtArgs> = {}>(args?: Subset<T, Action$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Action model
   */ 
  interface ActionFieldRefs {
    readonly id: FieldRef<"Action", 'String'>
    readonly name: FieldRef<"Action", 'String'>
    readonly zoneId: FieldRef<"Action", 'String'>
    readonly preconditions: FieldRef<"Action", 'Json'>
    readonly timeCost: FieldRef<"Action", 'Int'>
    readonly effects: FieldRef<"Action", 'Json'>
    readonly riskLevel: FieldRef<"Action", 'String'>
    readonly maskModifiers: FieldRef<"Action", 'Json'>
    readonly createdAt: FieldRef<"Action", 'DateTime'>
    readonly updatedAt: FieldRef<"Action", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Action findUnique
   */
  export type ActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findUniqueOrThrow
   */
  export type ActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action findFirst
   */
  export type ActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findFirstOrThrow
   */
  export type ActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Action to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Actions.
     */
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action findMany
   */
  export type ActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter, which Actions to fetch.
     */
    where?: ActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Actions to fetch.
     */
    orderBy?: ActionOrderByWithRelationInput | ActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Actions.
     */
    cursor?: ActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Actions.
     */
    skip?: number
    distinct?: ActionScalarFieldEnum | ActionScalarFieldEnum[]
  }

  /**
   * Action create
   */
  export type ActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to create a Action.
     */
    data: XOR<ActionCreateInput, ActionUncheckedCreateInput>
  }

  /**
   * Action createMany
   */
  export type ActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Action createManyAndReturn
   */
  export type ActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Actions.
     */
    data: ActionCreateManyInput | ActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Action update
   */
  export type ActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The data needed to update a Action.
     */
    data: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
    /**
     * Choose, which Action to update.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action updateMany
   */
  export type ActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Actions.
     */
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyInput>
    /**
     * Filter which Actions to update
     */
    where?: ActionWhereInput
  }

  /**
   * Action upsert
   */
  export type ActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * The filter to search for the Action to update in case it exists.
     */
    where: ActionWhereUniqueInput
    /**
     * In case the Action found by the `where` argument doesn't exist, create a new Action with this data.
     */
    create: XOR<ActionCreateInput, ActionUncheckedCreateInput>
    /**
     * In case the Action was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionUpdateInput, ActionUncheckedUpdateInput>
  }

  /**
   * Action delete
   */
  export type ActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
    /**
     * Filter which Action to delete.
     */
    where: ActionWhereUniqueInput
  }

  /**
   * Action deleteMany
   */
  export type ActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Actions to delete
     */
    where?: ActionWhereInput
  }

  /**
   * Action.zone
   */
  export type Action$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * Action without action
   */
  export type ActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Action
     */
    select?: ActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionInclude<ExtArgs> | null
  }


  /**
   * Model PlayerRelationship
   */

  export type AggregatePlayerRelationship = {
    _count: PlayerRelationshipCountAggregateOutputType | null
    _avg: PlayerRelationshipAvgAggregateOutputType | null
    _sum: PlayerRelationshipSumAggregateOutputType | null
    _min: PlayerRelationshipMinAggregateOutputType | null
    _max: PlayerRelationshipMaxAggregateOutputType | null
  }

  export type PlayerRelationshipAvgAggregateOutputType = {
    affinity: number | null
  }

  export type PlayerRelationshipSumAggregateOutputType = {
    affinity: number | null
  }

  export type PlayerRelationshipMinAggregateOutputType = {
    id: string | null
    playerId: string | null
    npcId: string | null
    affinity: number | null
  }

  export type PlayerRelationshipMaxAggregateOutputType = {
    id: string | null
    playerId: string | null
    npcId: string | null
    affinity: number | null
  }

  export type PlayerRelationshipCountAggregateOutputType = {
    id: number
    playerId: number
    npcId: number
    affinity: number
    _all: number
  }


  export type PlayerRelationshipAvgAggregateInputType = {
    affinity?: true
  }

  export type PlayerRelationshipSumAggregateInputType = {
    affinity?: true
  }

  export type PlayerRelationshipMinAggregateInputType = {
    id?: true
    playerId?: true
    npcId?: true
    affinity?: true
  }

  export type PlayerRelationshipMaxAggregateInputType = {
    id?: true
    playerId?: true
    npcId?: true
    affinity?: true
  }

  export type PlayerRelationshipCountAggregateInputType = {
    id?: true
    playerId?: true
    npcId?: true
    affinity?: true
    _all?: true
  }

  export type PlayerRelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerRelationship to aggregate.
     */
    where?: PlayerRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRelationships to fetch.
     */
    orderBy?: PlayerRelationshipOrderByWithRelationInput | PlayerRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlayerRelationships
    **/
    _count?: true | PlayerRelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlayerRelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlayerRelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerRelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerRelationshipMaxAggregateInputType
  }

  export type GetPlayerRelationshipAggregateType<T extends PlayerRelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayerRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayerRelationship[P]>
      : GetScalarType<T[P], AggregatePlayerRelationship[P]>
  }




  export type PlayerRelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerRelationshipWhereInput
    orderBy?: PlayerRelationshipOrderByWithAggregationInput | PlayerRelationshipOrderByWithAggregationInput[]
    by: PlayerRelationshipScalarFieldEnum[] | PlayerRelationshipScalarFieldEnum
    having?: PlayerRelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerRelationshipCountAggregateInputType | true
    _avg?: PlayerRelationshipAvgAggregateInputType
    _sum?: PlayerRelationshipSumAggregateInputType
    _min?: PlayerRelationshipMinAggregateInputType
    _max?: PlayerRelationshipMaxAggregateInputType
  }

  export type PlayerRelationshipGroupByOutputType = {
    id: string
    playerId: string
    npcId: string
    affinity: number
    _count: PlayerRelationshipCountAggregateOutputType | null
    _avg: PlayerRelationshipAvgAggregateOutputType | null
    _sum: PlayerRelationshipSumAggregateOutputType | null
    _min: PlayerRelationshipMinAggregateOutputType | null
    _max: PlayerRelationshipMaxAggregateOutputType | null
  }

  type GetPlayerRelationshipGroupByPayload<T extends PlayerRelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerRelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerRelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerRelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerRelationshipGroupByOutputType[P]>
        }
      >
    >


  export type PlayerRelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    npcId?: boolean
    affinity?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerRelationship"]>

  export type PlayerRelationshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    playerId?: boolean
    npcId?: boolean
    affinity?: boolean
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["playerRelationship"]>

  export type PlayerRelationshipSelectScalar = {
    id?: boolean
    playerId?: boolean
    npcId?: boolean
    affinity?: boolean
  }

  export type PlayerRelationshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }
  export type PlayerRelationshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    player?: boolean | PlayerDefaultArgs<ExtArgs>
    npc?: boolean | NPCDefaultArgs<ExtArgs>
  }

  export type $PlayerRelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlayerRelationship"
    objects: {
      player: Prisma.$PlayerPayload<ExtArgs>
      npc: Prisma.$NPCPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      playerId: string
      npcId: string
      affinity: number
    }, ExtArgs["result"]["playerRelationship"]>
    composites: {}
  }

  type PlayerRelationshipGetPayload<S extends boolean | null | undefined | PlayerRelationshipDefaultArgs> = $Result.GetResult<Prisma.$PlayerRelationshipPayload, S>

  type PlayerRelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlayerRelationshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlayerRelationshipCountAggregateInputType | true
    }

  export interface PlayerRelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlayerRelationship'], meta: { name: 'PlayerRelationship' } }
    /**
     * Find zero or one PlayerRelationship that matches the filter.
     * @param {PlayerRelationshipFindUniqueArgs} args - Arguments to find a PlayerRelationship
     * @example
     * // Get one PlayerRelationship
     * const playerRelationship = await prisma.playerRelationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerRelationshipFindUniqueArgs>(args: SelectSubset<T, PlayerRelationshipFindUniqueArgs<ExtArgs>>): Prisma__PlayerRelationshipClient<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PlayerRelationship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlayerRelationshipFindUniqueOrThrowArgs} args - Arguments to find a PlayerRelationship
     * @example
     * // Get one PlayerRelationship
     * const playerRelationship = await prisma.playerRelationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerRelationshipFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerRelationshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerRelationshipClient<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PlayerRelationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRelationshipFindFirstArgs} args - Arguments to find a PlayerRelationship
     * @example
     * // Get one PlayerRelationship
     * const playerRelationship = await prisma.playerRelationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerRelationshipFindFirstArgs>(args?: SelectSubset<T, PlayerRelationshipFindFirstArgs<ExtArgs>>): Prisma__PlayerRelationshipClient<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PlayerRelationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRelationshipFindFirstOrThrowArgs} args - Arguments to find a PlayerRelationship
     * @example
     * // Get one PlayerRelationship
     * const playerRelationship = await prisma.playerRelationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerRelationshipFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerRelationshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerRelationshipClient<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PlayerRelationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRelationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlayerRelationships
     * const playerRelationships = await prisma.playerRelationship.findMany()
     * 
     * // Get first 10 PlayerRelationships
     * const playerRelationships = await prisma.playerRelationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerRelationshipWithIdOnly = await prisma.playerRelationship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerRelationshipFindManyArgs>(args?: SelectSubset<T, PlayerRelationshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PlayerRelationship.
     * @param {PlayerRelationshipCreateArgs} args - Arguments to create a PlayerRelationship.
     * @example
     * // Create one PlayerRelationship
     * const PlayerRelationship = await prisma.playerRelationship.create({
     *   data: {
     *     // ... data to create a PlayerRelationship
     *   }
     * })
     * 
     */
    create<T extends PlayerRelationshipCreateArgs>(args: SelectSubset<T, PlayerRelationshipCreateArgs<ExtArgs>>): Prisma__PlayerRelationshipClient<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PlayerRelationships.
     * @param {PlayerRelationshipCreateManyArgs} args - Arguments to create many PlayerRelationships.
     * @example
     * // Create many PlayerRelationships
     * const playerRelationship = await prisma.playerRelationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerRelationshipCreateManyArgs>(args?: SelectSubset<T, PlayerRelationshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlayerRelationships and returns the data saved in the database.
     * @param {PlayerRelationshipCreateManyAndReturnArgs} args - Arguments to create many PlayerRelationships.
     * @example
     * // Create many PlayerRelationships
     * const playerRelationship = await prisma.playerRelationship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlayerRelationships and only return the `id`
     * const playerRelationshipWithIdOnly = await prisma.playerRelationship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerRelationshipCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerRelationshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PlayerRelationship.
     * @param {PlayerRelationshipDeleteArgs} args - Arguments to delete one PlayerRelationship.
     * @example
     * // Delete one PlayerRelationship
     * const PlayerRelationship = await prisma.playerRelationship.delete({
     *   where: {
     *     // ... filter to delete one PlayerRelationship
     *   }
     * })
     * 
     */
    delete<T extends PlayerRelationshipDeleteArgs>(args: SelectSubset<T, PlayerRelationshipDeleteArgs<ExtArgs>>): Prisma__PlayerRelationshipClient<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PlayerRelationship.
     * @param {PlayerRelationshipUpdateArgs} args - Arguments to update one PlayerRelationship.
     * @example
     * // Update one PlayerRelationship
     * const playerRelationship = await prisma.playerRelationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerRelationshipUpdateArgs>(args: SelectSubset<T, PlayerRelationshipUpdateArgs<ExtArgs>>): Prisma__PlayerRelationshipClient<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PlayerRelationships.
     * @param {PlayerRelationshipDeleteManyArgs} args - Arguments to filter PlayerRelationships to delete.
     * @example
     * // Delete a few PlayerRelationships
     * const { count } = await prisma.playerRelationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerRelationshipDeleteManyArgs>(args?: SelectSubset<T, PlayerRelationshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlayerRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlayerRelationships
     * const playerRelationship = await prisma.playerRelationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerRelationshipUpdateManyArgs>(args: SelectSubset<T, PlayerRelationshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PlayerRelationship.
     * @param {PlayerRelationshipUpsertArgs} args - Arguments to update or create a PlayerRelationship.
     * @example
     * // Update or create a PlayerRelationship
     * const playerRelationship = await prisma.playerRelationship.upsert({
     *   create: {
     *     // ... data to create a PlayerRelationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlayerRelationship we want to update
     *   }
     * })
     */
    upsert<T extends PlayerRelationshipUpsertArgs>(args: SelectSubset<T, PlayerRelationshipUpsertArgs<ExtArgs>>): Prisma__PlayerRelationshipClient<$Result.GetResult<Prisma.$PlayerRelationshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PlayerRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRelationshipCountArgs} args - Arguments to filter PlayerRelationships to count.
     * @example
     * // Count the number of PlayerRelationships
     * const count = await prisma.playerRelationship.count({
     *   where: {
     *     // ... the filter for the PlayerRelationships we want to count
     *   }
     * })
    **/
    count<T extends PlayerRelationshipCountArgs>(
      args?: Subset<T, PlayerRelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerRelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlayerRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerRelationshipAggregateArgs>(args: Subset<T, PlayerRelationshipAggregateArgs>): Prisma.PrismaPromise<GetPlayerRelationshipAggregateType<T>>

    /**
     * Group by PlayerRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerRelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerRelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerRelationshipGroupByArgs['orderBy'] }
        : { orderBy?: PlayerRelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerRelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlayerRelationship model
   */
  readonly fields: PlayerRelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlayerRelationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerRelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    npc<T extends NPCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NPCDefaultArgs<ExtArgs>>): Prisma__NPCClient<$Result.GetResult<Prisma.$NPCPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlayerRelationship model
   */ 
  interface PlayerRelationshipFieldRefs {
    readonly id: FieldRef<"PlayerRelationship", 'String'>
    readonly playerId: FieldRef<"PlayerRelationship", 'String'>
    readonly npcId: FieldRef<"PlayerRelationship", 'String'>
    readonly affinity: FieldRef<"PlayerRelationship", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PlayerRelationship findUnique
   */
  export type PlayerRelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRelationship to fetch.
     */
    where: PlayerRelationshipWhereUniqueInput
  }

  /**
   * PlayerRelationship findUniqueOrThrow
   */
  export type PlayerRelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRelationship to fetch.
     */
    where: PlayerRelationshipWhereUniqueInput
  }

  /**
   * PlayerRelationship findFirst
   */
  export type PlayerRelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRelationship to fetch.
     */
    where?: PlayerRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRelationships to fetch.
     */
    orderBy?: PlayerRelationshipOrderByWithRelationInput | PlayerRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerRelationships.
     */
    cursor?: PlayerRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerRelationships.
     */
    distinct?: PlayerRelationshipScalarFieldEnum | PlayerRelationshipScalarFieldEnum[]
  }

  /**
   * PlayerRelationship findFirstOrThrow
   */
  export type PlayerRelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRelationship to fetch.
     */
    where?: PlayerRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRelationships to fetch.
     */
    orderBy?: PlayerRelationshipOrderByWithRelationInput | PlayerRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlayerRelationships.
     */
    cursor?: PlayerRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlayerRelationships.
     */
    distinct?: PlayerRelationshipScalarFieldEnum | PlayerRelationshipScalarFieldEnum[]
  }

  /**
   * PlayerRelationship findMany
   */
  export type PlayerRelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which PlayerRelationships to fetch.
     */
    where?: PlayerRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlayerRelationships to fetch.
     */
    orderBy?: PlayerRelationshipOrderByWithRelationInput | PlayerRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlayerRelationships.
     */
    cursor?: PlayerRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlayerRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlayerRelationships.
     */
    skip?: number
    distinct?: PlayerRelationshipScalarFieldEnum | PlayerRelationshipScalarFieldEnum[]
  }

  /**
   * PlayerRelationship create
   */
  export type PlayerRelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a PlayerRelationship.
     */
    data: XOR<PlayerRelationshipCreateInput, PlayerRelationshipUncheckedCreateInput>
  }

  /**
   * PlayerRelationship createMany
   */
  export type PlayerRelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlayerRelationships.
     */
    data: PlayerRelationshipCreateManyInput | PlayerRelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlayerRelationship createManyAndReturn
   */
  export type PlayerRelationshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PlayerRelationships.
     */
    data: PlayerRelationshipCreateManyInput | PlayerRelationshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlayerRelationship update
   */
  export type PlayerRelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a PlayerRelationship.
     */
    data: XOR<PlayerRelationshipUpdateInput, PlayerRelationshipUncheckedUpdateInput>
    /**
     * Choose, which PlayerRelationship to update.
     */
    where: PlayerRelationshipWhereUniqueInput
  }

  /**
   * PlayerRelationship updateMany
   */
  export type PlayerRelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlayerRelationships.
     */
    data: XOR<PlayerRelationshipUpdateManyMutationInput, PlayerRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which PlayerRelationships to update
     */
    where?: PlayerRelationshipWhereInput
  }

  /**
   * PlayerRelationship upsert
   */
  export type PlayerRelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the PlayerRelationship to update in case it exists.
     */
    where: PlayerRelationshipWhereUniqueInput
    /**
     * In case the PlayerRelationship found by the `where` argument doesn't exist, create a new PlayerRelationship with this data.
     */
    create: XOR<PlayerRelationshipCreateInput, PlayerRelationshipUncheckedCreateInput>
    /**
     * In case the PlayerRelationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerRelationshipUpdateInput, PlayerRelationshipUncheckedUpdateInput>
  }

  /**
   * PlayerRelationship delete
   */
  export type PlayerRelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
    /**
     * Filter which PlayerRelationship to delete.
     */
    where: PlayerRelationshipWhereUniqueInput
  }

  /**
   * PlayerRelationship deleteMany
   */
  export type PlayerRelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlayerRelationships to delete
     */
    where?: PlayerRelationshipWhereInput
  }

  /**
   * PlayerRelationship without action
   */
  export type PlayerRelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerRelationship
     */
    select?: PlayerRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerRelationshipInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    username: 'username',
    avatar: 'avatar',
    grade: 'grade',
    className: 'className',
    currentMaskId: 'currentMaskId',
    energy: 'energy',
    mood: 'mood',
    time: 'time',
    reputation: 'reputation',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const MaskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    alias: 'alias',
    description: 'description',
    personality: 'personality',
    corruption: 'corruption',
    abilities: 'abilities',
    dailyEffects: 'dailyEffects',
    corruptionTriggers: 'corruptionTriggers',
    unlockRequirements: 'unlockRequirements',
    image: 'image',
    symbol: 'symbol',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaskScalarFieldEnum = (typeof MaskScalarFieldEnum)[keyof typeof MaskScalarFieldEnum]


  export const PlayerMaskScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    maskId: 'maskId',
    corruption: 'corruption'
  };

  export type PlayerMaskScalarFieldEnum = (typeof PlayerMaskScalarFieldEnum)[keyof typeof PlayerMaskScalarFieldEnum]


  export const NPCScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    traits: 'traits',
    personality: 'personality',
    schedule: 'schedule',
    relationship: 'relationship',
    rumorScore: 'rumorScore',
    reactions: 'reactions',
    events: 'events',
    portrait: 'portrait',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NPCScalarFieldEnum = (typeof NPCScalarFieldEnum)[keyof typeof NPCScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    effects: 'effects',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const PlayerItemScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    itemId: 'itemId',
    quantity: 'quantity'
  };

  export type PlayerItemScalarFieldEnum = (typeof PlayerItemScalarFieldEnum)[keyof typeof PlayerItemScalarFieldEnum]


  export const MinigameScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    name: 'name',
    description: 'description',
    difficulty: 'difficulty',
    maskModifiers: 'maskModifiers',
    rewards: 'rewards',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MinigameScalarFieldEnum = (typeof MinigameScalarFieldEnum)[keyof typeof MinigameScalarFieldEnum]


  export const PlayerMinigameScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    minigameId: 'minigameId',
    score: 'score',
    completed: 'completed'
  };

  export type PlayerMinigameScalarFieldEnum = (typeof PlayerMinigameScalarFieldEnum)[keyof typeof PlayerMinigameScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    name: 'name',
    triggerChance: 'triggerChance',
    triggerZones: 'triggerZones',
    maskModifiers: 'maskModifiers',
    choices: 'choices',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const PlayerEventScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    eventId: 'eventId',
    choiceMade: 'choiceMade',
    completed: 'completed'
  };

  export type PlayerEventScalarFieldEnum = (typeof PlayerEventScalarFieldEnum)[keyof typeof PlayerEventScalarFieldEnum]


  export const ActionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    zoneId: 'zoneId',
    preconditions: 'preconditions',
    timeCost: 'timeCost',
    effects: 'effects',
    riskLevel: 'riskLevel',
    maskModifiers: 'maskModifiers',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActionScalarFieldEnum = (typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum]


  export const PlayerRelationshipScalarFieldEnum: {
    id: 'id',
    playerId: 'playerId',
    npcId: 'npcId',
    affinity: 'affinity'
  };

  export type PlayerRelationshipScalarFieldEnum = (typeof PlayerRelationshipScalarFieldEnum)[keyof typeof PlayerRelationshipScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: StringFilter<"Player"> | string
    username?: StringFilter<"Player"> | string
    avatar?: StringFilter<"Player"> | string
    grade?: IntFilter<"Player"> | number
    className?: StringFilter<"Player"> | string
    currentMaskId?: StringNullableFilter<"Player"> | string | null
    energy?: IntFilter<"Player"> | number
    mood?: StringFilter<"Player"> | string
    time?: StringFilter<"Player"> | string
    reputation?: IntFilter<"Player"> | number
    zoneId?: StringNullableFilter<"Player"> | string | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    currentMask?: XOR<MaskNullableRelationFilter, MaskWhereInput> | null
    masksOwned?: PlayerMaskListRelationFilter
    relationships?: PlayerRelationshipListRelationFilter
    inventory?: PlayerItemListRelationFilter
    minigameProgress?: PlayerMinigameListRelationFilter
    eventsCompleted?: PlayerEventListRelationFilter
    location?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    grade?: SortOrder
    className?: SortOrder
    currentMaskId?: SortOrderInput | SortOrder
    energy?: SortOrder
    mood?: SortOrder
    time?: SortOrder
    reputation?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    currentMask?: MaskOrderByWithRelationInput
    masksOwned?: PlayerMaskOrderByRelationAggregateInput
    relationships?: PlayerRelationshipOrderByRelationAggregateInput
    inventory?: PlayerItemOrderByRelationAggregateInput
    minigameProgress?: PlayerMinigameOrderByRelationAggregateInput
    eventsCompleted?: PlayerEventOrderByRelationAggregateInput
    location?: ZoneOrderByWithRelationInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    avatar?: StringFilter<"Player"> | string
    grade?: IntFilter<"Player"> | number
    className?: StringFilter<"Player"> | string
    currentMaskId?: StringNullableFilter<"Player"> | string | null
    energy?: IntFilter<"Player"> | number
    mood?: StringFilter<"Player"> | string
    time?: StringFilter<"Player"> | string
    reputation?: IntFilter<"Player"> | number
    zoneId?: StringNullableFilter<"Player"> | string | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
    currentMask?: XOR<MaskNullableRelationFilter, MaskWhereInput> | null
    masksOwned?: PlayerMaskListRelationFilter
    relationships?: PlayerRelationshipListRelationFilter
    inventory?: PlayerItemListRelationFilter
    minigameProgress?: PlayerMinigameListRelationFilter
    eventsCompleted?: PlayerEventListRelationFilter
    location?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
  }, "id" | "username">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    grade?: SortOrder
    className?: SortOrder
    currentMaskId?: SortOrderInput | SortOrder
    energy?: SortOrder
    mood?: SortOrder
    time?: SortOrder
    reputation?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _avg?: PlayerAvgOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
    _sum?: PlayerSumOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Player"> | string
    username?: StringWithAggregatesFilter<"Player"> | string
    avatar?: StringWithAggregatesFilter<"Player"> | string
    grade?: IntWithAggregatesFilter<"Player"> | number
    className?: StringWithAggregatesFilter<"Player"> | string
    currentMaskId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    energy?: IntWithAggregatesFilter<"Player"> | number
    mood?: StringWithAggregatesFilter<"Player"> | string
    time?: StringWithAggregatesFilter<"Player"> | string
    reputation?: IntWithAggregatesFilter<"Player"> | number
    zoneId?: StringNullableWithAggregatesFilter<"Player"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
  }

  export type MaskWhereInput = {
    AND?: MaskWhereInput | MaskWhereInput[]
    OR?: MaskWhereInput[]
    NOT?: MaskWhereInput | MaskWhereInput[]
    id?: StringFilter<"Mask"> | string
    name?: StringFilter<"Mask"> | string
    alias?: StringFilter<"Mask"> | string
    description?: StringFilter<"Mask"> | string
    personality?: StringFilter<"Mask"> | string
    corruption?: IntFilter<"Mask"> | number
    abilities?: JsonFilter<"Mask">
    dailyEffects?: JsonFilter<"Mask">
    corruptionTriggers?: StringNullableListFilter<"Mask">
    unlockRequirements?: StringNullableListFilter<"Mask">
    image?: StringFilter<"Mask"> | string
    symbol?: StringFilter<"Mask"> | string
    createdAt?: DateTimeFilter<"Mask"> | Date | string
    updatedAt?: DateTimeFilter<"Mask"> | Date | string
    players?: PlayerMaskListRelationFilter
    currentPlayers?: PlayerListRelationFilter
  }

  export type MaskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    personality?: SortOrder
    corruption?: SortOrder
    abilities?: SortOrder
    dailyEffects?: SortOrder
    corruptionTriggers?: SortOrder
    unlockRequirements?: SortOrder
    image?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    players?: PlayerMaskOrderByRelationAggregateInput
    currentPlayers?: PlayerOrderByRelationAggregateInput
  }

  export type MaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaskWhereInput | MaskWhereInput[]
    OR?: MaskWhereInput[]
    NOT?: MaskWhereInput | MaskWhereInput[]
    name?: StringFilter<"Mask"> | string
    alias?: StringFilter<"Mask"> | string
    description?: StringFilter<"Mask"> | string
    personality?: StringFilter<"Mask"> | string
    corruption?: IntFilter<"Mask"> | number
    abilities?: JsonFilter<"Mask">
    dailyEffects?: JsonFilter<"Mask">
    corruptionTriggers?: StringNullableListFilter<"Mask">
    unlockRequirements?: StringNullableListFilter<"Mask">
    image?: StringFilter<"Mask"> | string
    symbol?: StringFilter<"Mask"> | string
    createdAt?: DateTimeFilter<"Mask"> | Date | string
    updatedAt?: DateTimeFilter<"Mask"> | Date | string
    players?: PlayerMaskListRelationFilter
    currentPlayers?: PlayerListRelationFilter
  }, "id">

  export type MaskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    personality?: SortOrder
    corruption?: SortOrder
    abilities?: SortOrder
    dailyEffects?: SortOrder
    corruptionTriggers?: SortOrder
    unlockRequirements?: SortOrder
    image?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaskCountOrderByAggregateInput
    _avg?: MaskAvgOrderByAggregateInput
    _max?: MaskMaxOrderByAggregateInput
    _min?: MaskMinOrderByAggregateInput
    _sum?: MaskSumOrderByAggregateInput
  }

  export type MaskScalarWhereWithAggregatesInput = {
    AND?: MaskScalarWhereWithAggregatesInput | MaskScalarWhereWithAggregatesInput[]
    OR?: MaskScalarWhereWithAggregatesInput[]
    NOT?: MaskScalarWhereWithAggregatesInput | MaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mask"> | string
    name?: StringWithAggregatesFilter<"Mask"> | string
    alias?: StringWithAggregatesFilter<"Mask"> | string
    description?: StringWithAggregatesFilter<"Mask"> | string
    personality?: StringWithAggregatesFilter<"Mask"> | string
    corruption?: IntWithAggregatesFilter<"Mask"> | number
    abilities?: JsonWithAggregatesFilter<"Mask">
    dailyEffects?: JsonWithAggregatesFilter<"Mask">
    corruptionTriggers?: StringNullableListFilter<"Mask">
    unlockRequirements?: StringNullableListFilter<"Mask">
    image?: StringWithAggregatesFilter<"Mask"> | string
    symbol?: StringWithAggregatesFilter<"Mask"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Mask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Mask"> | Date | string
  }

  export type PlayerMaskWhereInput = {
    AND?: PlayerMaskWhereInput | PlayerMaskWhereInput[]
    OR?: PlayerMaskWhereInput[]
    NOT?: PlayerMaskWhereInput | PlayerMaskWhereInput[]
    id?: StringFilter<"PlayerMask"> | string
    playerId?: StringFilter<"PlayerMask"> | string
    maskId?: StringFilter<"PlayerMask"> | string
    corruption?: IntFilter<"PlayerMask"> | number
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    mask?: XOR<MaskRelationFilter, MaskWhereInput>
  }

  export type PlayerMaskOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    maskId?: SortOrder
    corruption?: SortOrder
    player?: PlayerOrderByWithRelationInput
    mask?: MaskOrderByWithRelationInput
  }

  export type PlayerMaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_maskId?: PlayerMaskPlayerIdMaskIdCompoundUniqueInput
    AND?: PlayerMaskWhereInput | PlayerMaskWhereInput[]
    OR?: PlayerMaskWhereInput[]
    NOT?: PlayerMaskWhereInput | PlayerMaskWhereInput[]
    playerId?: StringFilter<"PlayerMask"> | string
    maskId?: StringFilter<"PlayerMask"> | string
    corruption?: IntFilter<"PlayerMask"> | number
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    mask?: XOR<MaskRelationFilter, MaskWhereInput>
  }, "id" | "playerId_maskId">

  export type PlayerMaskOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    maskId?: SortOrder
    corruption?: SortOrder
    _count?: PlayerMaskCountOrderByAggregateInput
    _avg?: PlayerMaskAvgOrderByAggregateInput
    _max?: PlayerMaskMaxOrderByAggregateInput
    _min?: PlayerMaskMinOrderByAggregateInput
    _sum?: PlayerMaskSumOrderByAggregateInput
  }

  export type PlayerMaskScalarWhereWithAggregatesInput = {
    AND?: PlayerMaskScalarWhereWithAggregatesInput | PlayerMaskScalarWhereWithAggregatesInput[]
    OR?: PlayerMaskScalarWhereWithAggregatesInput[]
    NOT?: PlayerMaskScalarWhereWithAggregatesInput | PlayerMaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerMask"> | string
    playerId?: StringWithAggregatesFilter<"PlayerMask"> | string
    maskId?: StringWithAggregatesFilter<"PlayerMask"> | string
    corruption?: IntWithAggregatesFilter<"PlayerMask"> | number
  }

  export type NPCWhereInput = {
    AND?: NPCWhereInput | NPCWhereInput[]
    OR?: NPCWhereInput[]
    NOT?: NPCWhereInput | NPCWhereInput[]
    id?: StringFilter<"NPC"> | string
    name?: StringFilter<"NPC"> | string
    role?: StringFilter<"NPC"> | string
    traits?: StringNullableListFilter<"NPC">
    personality?: StringFilter<"NPC"> | string
    schedule?: JsonFilter<"NPC">
    relationship?: IntFilter<"NPC"> | number
    rumorScore?: IntFilter<"NPC"> | number
    reactions?: JsonFilter<"NPC">
    events?: StringNullableListFilter<"NPC">
    portrait?: StringFilter<"NPC"> | string
    zoneId?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
    updatedAt?: DateTimeFilter<"NPC"> | Date | string
    location?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    playerRelationships?: PlayerRelationshipListRelationFilter
  }

  export type NPCOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    traits?: SortOrder
    personality?: SortOrder
    schedule?: SortOrder
    relationship?: SortOrder
    rumorScore?: SortOrder
    reactions?: SortOrder
    events?: SortOrder
    portrait?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: ZoneOrderByWithRelationInput
    playerRelationships?: PlayerRelationshipOrderByRelationAggregateInput
  }

  export type NPCWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NPCWhereInput | NPCWhereInput[]
    OR?: NPCWhereInput[]
    NOT?: NPCWhereInput | NPCWhereInput[]
    name?: StringFilter<"NPC"> | string
    role?: StringFilter<"NPC"> | string
    traits?: StringNullableListFilter<"NPC">
    personality?: StringFilter<"NPC"> | string
    schedule?: JsonFilter<"NPC">
    relationship?: IntFilter<"NPC"> | number
    rumorScore?: IntFilter<"NPC"> | number
    reactions?: JsonFilter<"NPC">
    events?: StringNullableListFilter<"NPC">
    portrait?: StringFilter<"NPC"> | string
    zoneId?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
    updatedAt?: DateTimeFilter<"NPC"> | Date | string
    location?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    playerRelationships?: PlayerRelationshipListRelationFilter
  }, "id">

  export type NPCOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    traits?: SortOrder
    personality?: SortOrder
    schedule?: SortOrder
    relationship?: SortOrder
    rumorScore?: SortOrder
    reactions?: SortOrder
    events?: SortOrder
    portrait?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NPCCountOrderByAggregateInput
    _avg?: NPCAvgOrderByAggregateInput
    _max?: NPCMaxOrderByAggregateInput
    _min?: NPCMinOrderByAggregateInput
    _sum?: NPCSumOrderByAggregateInput
  }

  export type NPCScalarWhereWithAggregatesInput = {
    AND?: NPCScalarWhereWithAggregatesInput | NPCScalarWhereWithAggregatesInput[]
    OR?: NPCScalarWhereWithAggregatesInput[]
    NOT?: NPCScalarWhereWithAggregatesInput | NPCScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NPC"> | string
    name?: StringWithAggregatesFilter<"NPC"> | string
    role?: StringWithAggregatesFilter<"NPC"> | string
    traits?: StringNullableListFilter<"NPC">
    personality?: StringWithAggregatesFilter<"NPC"> | string
    schedule?: JsonWithAggregatesFilter<"NPC">
    relationship?: IntWithAggregatesFilter<"NPC"> | number
    rumorScore?: IntWithAggregatesFilter<"NPC"> | number
    reactions?: JsonWithAggregatesFilter<"NPC">
    events?: StringNullableListFilter<"NPC">
    portrait?: StringWithAggregatesFilter<"NPC"> | string
    zoneId?: StringNullableWithAggregatesFilter<"NPC"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NPC"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NPC"> | Date | string
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    type?: StringFilter<"Zone"> | string
    description?: StringNullableFilter<"Zone"> | string | null
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    npcs?: NPCListRelationFilter
    players?: PlayerListRelationFilter
    events?: EventListRelationFilter
    actions?: ActionListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    npcs?: NPCOrderByRelationAggregateInput
    players?: PlayerOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    actions?: ActionOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    name?: StringFilter<"Zone"> | string
    type?: StringFilter<"Zone"> | string
    description?: StringNullableFilter<"Zone"> | string | null
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    npcs?: NPCListRelationFilter
    players?: PlayerListRelationFilter
    events?: EventListRelationFilter
    actions?: ActionListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    name?: StringWithAggregatesFilter<"Zone"> | string
    type?: StringWithAggregatesFilter<"Zone"> | string
    description?: StringNullableWithAggregatesFilter<"Zone"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    type?: StringFilter<"Item"> | string
    description?: StringFilter<"Item"> | string
    effects?: JsonFilter<"Item">
    image?: StringFilter<"Item"> | string
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    players?: PlayerItemListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    effects?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    players?: PlayerItemOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    name?: StringFilter<"Item"> | string
    type?: StringFilter<"Item"> | string
    description?: StringFilter<"Item"> | string
    effects?: JsonFilter<"Item">
    image?: StringFilter<"Item"> | string
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    players?: PlayerItemListRelationFilter
  }, "id">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    effects?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    type?: StringWithAggregatesFilter<"Item"> | string
    description?: StringWithAggregatesFilter<"Item"> | string
    effects?: JsonWithAggregatesFilter<"Item">
    image?: StringWithAggregatesFilter<"Item"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type PlayerItemWhereInput = {
    AND?: PlayerItemWhereInput | PlayerItemWhereInput[]
    OR?: PlayerItemWhereInput[]
    NOT?: PlayerItemWhereInput | PlayerItemWhereInput[]
    id?: StringFilter<"PlayerItem"> | string
    playerId?: StringFilter<"PlayerItem"> | string
    itemId?: StringFilter<"PlayerItem"> | string
    quantity?: IntFilter<"PlayerItem"> | number
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type PlayerItemOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    player?: PlayerOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type PlayerItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_itemId?: PlayerItemPlayerIdItemIdCompoundUniqueInput
    AND?: PlayerItemWhereInput | PlayerItemWhereInput[]
    OR?: PlayerItemWhereInput[]
    NOT?: PlayerItemWhereInput | PlayerItemWhereInput[]
    playerId?: StringFilter<"PlayerItem"> | string
    itemId?: StringFilter<"PlayerItem"> | string
    quantity?: IntFilter<"PlayerItem"> | number
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "id" | "playerId_itemId">

  export type PlayerItemOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    _count?: PlayerItemCountOrderByAggregateInput
    _avg?: PlayerItemAvgOrderByAggregateInput
    _max?: PlayerItemMaxOrderByAggregateInput
    _min?: PlayerItemMinOrderByAggregateInput
    _sum?: PlayerItemSumOrderByAggregateInput
  }

  export type PlayerItemScalarWhereWithAggregatesInput = {
    AND?: PlayerItemScalarWhereWithAggregatesInput | PlayerItemScalarWhereWithAggregatesInput[]
    OR?: PlayerItemScalarWhereWithAggregatesInput[]
    NOT?: PlayerItemScalarWhereWithAggregatesInput | PlayerItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerItem"> | string
    playerId?: StringWithAggregatesFilter<"PlayerItem"> | string
    itemId?: StringWithAggregatesFilter<"PlayerItem"> | string
    quantity?: IntWithAggregatesFilter<"PlayerItem"> | number
  }

  export type MinigameWhereInput = {
    AND?: MinigameWhereInput | MinigameWhereInput[]
    OR?: MinigameWhereInput[]
    NOT?: MinigameWhereInput | MinigameWhereInput[]
    id?: StringFilter<"Minigame"> | string
    classId?: StringFilter<"Minigame"> | string
    name?: StringFilter<"Minigame"> | string
    description?: StringFilter<"Minigame"> | string
    difficulty?: IntFilter<"Minigame"> | number
    maskModifiers?: JsonFilter<"Minigame">
    rewards?: JsonFilter<"Minigame">
    createdAt?: DateTimeFilter<"Minigame"> | Date | string
    updatedAt?: DateTimeFilter<"Minigame"> | Date | string
    playerProgress?: PlayerMinigameListRelationFilter
  }

  export type MinigameOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    maskModifiers?: SortOrder
    rewards?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    playerProgress?: PlayerMinigameOrderByRelationAggregateInput
  }

  export type MinigameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MinigameWhereInput | MinigameWhereInput[]
    OR?: MinigameWhereInput[]
    NOT?: MinigameWhereInput | MinigameWhereInput[]
    classId?: StringFilter<"Minigame"> | string
    name?: StringFilter<"Minigame"> | string
    description?: StringFilter<"Minigame"> | string
    difficulty?: IntFilter<"Minigame"> | number
    maskModifiers?: JsonFilter<"Minigame">
    rewards?: JsonFilter<"Minigame">
    createdAt?: DateTimeFilter<"Minigame"> | Date | string
    updatedAt?: DateTimeFilter<"Minigame"> | Date | string
    playerProgress?: PlayerMinigameListRelationFilter
  }, "id">

  export type MinigameOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    maskModifiers?: SortOrder
    rewards?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MinigameCountOrderByAggregateInput
    _avg?: MinigameAvgOrderByAggregateInput
    _max?: MinigameMaxOrderByAggregateInput
    _min?: MinigameMinOrderByAggregateInput
    _sum?: MinigameSumOrderByAggregateInput
  }

  export type MinigameScalarWhereWithAggregatesInput = {
    AND?: MinigameScalarWhereWithAggregatesInput | MinigameScalarWhereWithAggregatesInput[]
    OR?: MinigameScalarWhereWithAggregatesInput[]
    NOT?: MinigameScalarWhereWithAggregatesInput | MinigameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Minigame"> | string
    classId?: StringWithAggregatesFilter<"Minigame"> | string
    name?: StringWithAggregatesFilter<"Minigame"> | string
    description?: StringWithAggregatesFilter<"Minigame"> | string
    difficulty?: IntWithAggregatesFilter<"Minigame"> | number
    maskModifiers?: JsonWithAggregatesFilter<"Minigame">
    rewards?: JsonWithAggregatesFilter<"Minigame">
    createdAt?: DateTimeWithAggregatesFilter<"Minigame"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Minigame"> | Date | string
  }

  export type PlayerMinigameWhereInput = {
    AND?: PlayerMinigameWhereInput | PlayerMinigameWhereInput[]
    OR?: PlayerMinigameWhereInput[]
    NOT?: PlayerMinigameWhereInput | PlayerMinigameWhereInput[]
    id?: StringFilter<"PlayerMinigame"> | string
    playerId?: StringFilter<"PlayerMinigame"> | string
    minigameId?: StringFilter<"PlayerMinigame"> | string
    score?: IntFilter<"PlayerMinigame"> | number
    completed?: BoolFilter<"PlayerMinigame"> | boolean
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    minigame?: XOR<MinigameRelationFilter, MinigameWhereInput>
  }

  export type PlayerMinigameOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    minigameId?: SortOrder
    score?: SortOrder
    completed?: SortOrder
    player?: PlayerOrderByWithRelationInput
    minigame?: MinigameOrderByWithRelationInput
  }

  export type PlayerMinigameWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_minigameId?: PlayerMinigamePlayerIdMinigameIdCompoundUniqueInput
    AND?: PlayerMinigameWhereInput | PlayerMinigameWhereInput[]
    OR?: PlayerMinigameWhereInput[]
    NOT?: PlayerMinigameWhereInput | PlayerMinigameWhereInput[]
    playerId?: StringFilter<"PlayerMinigame"> | string
    minigameId?: StringFilter<"PlayerMinigame"> | string
    score?: IntFilter<"PlayerMinigame"> | number
    completed?: BoolFilter<"PlayerMinigame"> | boolean
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    minigame?: XOR<MinigameRelationFilter, MinigameWhereInput>
  }, "id" | "playerId_minigameId">

  export type PlayerMinigameOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    minigameId?: SortOrder
    score?: SortOrder
    completed?: SortOrder
    _count?: PlayerMinigameCountOrderByAggregateInput
    _avg?: PlayerMinigameAvgOrderByAggregateInput
    _max?: PlayerMinigameMaxOrderByAggregateInput
    _min?: PlayerMinigameMinOrderByAggregateInput
    _sum?: PlayerMinigameSumOrderByAggregateInput
  }

  export type PlayerMinigameScalarWhereWithAggregatesInput = {
    AND?: PlayerMinigameScalarWhereWithAggregatesInput | PlayerMinigameScalarWhereWithAggregatesInput[]
    OR?: PlayerMinigameScalarWhereWithAggregatesInput[]
    NOT?: PlayerMinigameScalarWhereWithAggregatesInput | PlayerMinigameScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerMinigame"> | string
    playerId?: StringWithAggregatesFilter<"PlayerMinigame"> | string
    minigameId?: StringWithAggregatesFilter<"PlayerMinigame"> | string
    score?: IntWithAggregatesFilter<"PlayerMinigame"> | number
    completed?: BoolWithAggregatesFilter<"PlayerMinigame"> | boolean
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    name?: StringFilter<"Event"> | string
    triggerChance?: IntFilter<"Event"> | number
    triggerZones?: StringNullableListFilter<"Event">
    maskModifiers?: JsonFilter<"Event">
    choices?: JsonFilter<"Event">
    zoneId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    players?: PlayerEventListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    triggerChance?: SortOrder
    triggerZones?: SortOrder
    maskModifiers?: SortOrder
    choices?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zone?: ZoneOrderByWithRelationInput
    players?: PlayerEventOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    name?: StringFilter<"Event"> | string
    triggerChance?: IntFilter<"Event"> | number
    triggerZones?: StringNullableListFilter<"Event">
    maskModifiers?: JsonFilter<"Event">
    choices?: JsonFilter<"Event">
    zoneId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    players?: PlayerEventListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    triggerChance?: SortOrder
    triggerZones?: SortOrder
    maskModifiers?: SortOrder
    choices?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    name?: StringWithAggregatesFilter<"Event"> | string
    triggerChance?: IntWithAggregatesFilter<"Event"> | number
    triggerZones?: StringNullableListFilter<"Event">
    maskModifiers?: JsonWithAggregatesFilter<"Event">
    choices?: JsonWithAggregatesFilter<"Event">
    zoneId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type PlayerEventWhereInput = {
    AND?: PlayerEventWhereInput | PlayerEventWhereInput[]
    OR?: PlayerEventWhereInput[]
    NOT?: PlayerEventWhereInput | PlayerEventWhereInput[]
    id?: StringFilter<"PlayerEvent"> | string
    playerId?: StringFilter<"PlayerEvent"> | string
    eventId?: StringFilter<"PlayerEvent"> | string
    choiceMade?: StringNullableFilter<"PlayerEvent"> | string | null
    completed?: BoolFilter<"PlayerEvent"> | boolean
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
  }

  export type PlayerEventOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    eventId?: SortOrder
    choiceMade?: SortOrderInput | SortOrder
    completed?: SortOrder
    player?: PlayerOrderByWithRelationInput
    event?: EventOrderByWithRelationInput
  }

  export type PlayerEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_eventId?: PlayerEventPlayerIdEventIdCompoundUniqueInput
    AND?: PlayerEventWhereInput | PlayerEventWhereInput[]
    OR?: PlayerEventWhereInput[]
    NOT?: PlayerEventWhereInput | PlayerEventWhereInput[]
    playerId?: StringFilter<"PlayerEvent"> | string
    eventId?: StringFilter<"PlayerEvent"> | string
    choiceMade?: StringNullableFilter<"PlayerEvent"> | string | null
    completed?: BoolFilter<"PlayerEvent"> | boolean
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    event?: XOR<EventRelationFilter, EventWhereInput>
  }, "id" | "playerId_eventId">

  export type PlayerEventOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    eventId?: SortOrder
    choiceMade?: SortOrderInput | SortOrder
    completed?: SortOrder
    _count?: PlayerEventCountOrderByAggregateInput
    _max?: PlayerEventMaxOrderByAggregateInput
    _min?: PlayerEventMinOrderByAggregateInput
  }

  export type PlayerEventScalarWhereWithAggregatesInput = {
    AND?: PlayerEventScalarWhereWithAggregatesInput | PlayerEventScalarWhereWithAggregatesInput[]
    OR?: PlayerEventScalarWhereWithAggregatesInput[]
    NOT?: PlayerEventScalarWhereWithAggregatesInput | PlayerEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerEvent"> | string
    playerId?: StringWithAggregatesFilter<"PlayerEvent"> | string
    eventId?: StringWithAggregatesFilter<"PlayerEvent"> | string
    choiceMade?: StringNullableWithAggregatesFilter<"PlayerEvent"> | string | null
    completed?: BoolWithAggregatesFilter<"PlayerEvent"> | boolean
  }

  export type ActionWhereInput = {
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    id?: StringFilter<"Action"> | string
    name?: StringFilter<"Action"> | string
    zoneId?: StringNullableFilter<"Action"> | string | null
    preconditions?: JsonFilter<"Action">
    timeCost?: IntFilter<"Action"> | number
    effects?: JsonFilter<"Action">
    riskLevel?: StringFilter<"Action"> | string
    maskModifiers?: JsonFilter<"Action">
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
  }

  export type ActionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    preconditions?: SortOrder
    timeCost?: SortOrder
    effects?: SortOrder
    riskLevel?: SortOrder
    maskModifiers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    zone?: ZoneOrderByWithRelationInput
  }

  export type ActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActionWhereInput | ActionWhereInput[]
    OR?: ActionWhereInput[]
    NOT?: ActionWhereInput | ActionWhereInput[]
    name?: StringFilter<"Action"> | string
    zoneId?: StringNullableFilter<"Action"> | string | null
    preconditions?: JsonFilter<"Action">
    timeCost?: IntFilter<"Action"> | number
    effects?: JsonFilter<"Action">
    riskLevel?: StringFilter<"Action"> | string
    maskModifiers?: JsonFilter<"Action">
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
  }, "id">

  export type ActionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    preconditions?: SortOrder
    timeCost?: SortOrder
    effects?: SortOrder
    riskLevel?: SortOrder
    maskModifiers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActionCountOrderByAggregateInput
    _avg?: ActionAvgOrderByAggregateInput
    _max?: ActionMaxOrderByAggregateInput
    _min?: ActionMinOrderByAggregateInput
    _sum?: ActionSumOrderByAggregateInput
  }

  export type ActionScalarWhereWithAggregatesInput = {
    AND?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    OR?: ActionScalarWhereWithAggregatesInput[]
    NOT?: ActionScalarWhereWithAggregatesInput | ActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Action"> | string
    name?: StringWithAggregatesFilter<"Action"> | string
    zoneId?: StringNullableWithAggregatesFilter<"Action"> | string | null
    preconditions?: JsonWithAggregatesFilter<"Action">
    timeCost?: IntWithAggregatesFilter<"Action"> | number
    effects?: JsonWithAggregatesFilter<"Action">
    riskLevel?: StringWithAggregatesFilter<"Action"> | string
    maskModifiers?: JsonWithAggregatesFilter<"Action">
    createdAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Action"> | Date | string
  }

  export type PlayerRelationshipWhereInput = {
    AND?: PlayerRelationshipWhereInput | PlayerRelationshipWhereInput[]
    OR?: PlayerRelationshipWhereInput[]
    NOT?: PlayerRelationshipWhereInput | PlayerRelationshipWhereInput[]
    id?: StringFilter<"PlayerRelationship"> | string
    playerId?: StringFilter<"PlayerRelationship"> | string
    npcId?: StringFilter<"PlayerRelationship"> | string
    affinity?: IntFilter<"PlayerRelationship"> | number
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    npc?: XOR<NPCRelationFilter, NPCWhereInput>
  }

  export type PlayerRelationshipOrderByWithRelationInput = {
    id?: SortOrder
    playerId?: SortOrder
    npcId?: SortOrder
    affinity?: SortOrder
    player?: PlayerOrderByWithRelationInput
    npc?: NPCOrderByWithRelationInput
  }

  export type PlayerRelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    playerId_npcId?: PlayerRelationshipPlayerIdNpcIdCompoundUniqueInput
    AND?: PlayerRelationshipWhereInput | PlayerRelationshipWhereInput[]
    OR?: PlayerRelationshipWhereInput[]
    NOT?: PlayerRelationshipWhereInput | PlayerRelationshipWhereInput[]
    playerId?: StringFilter<"PlayerRelationship"> | string
    npcId?: StringFilter<"PlayerRelationship"> | string
    affinity?: IntFilter<"PlayerRelationship"> | number
    player?: XOR<PlayerRelationFilter, PlayerWhereInput>
    npc?: XOR<NPCRelationFilter, NPCWhereInput>
  }, "id" | "playerId_npcId">

  export type PlayerRelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    playerId?: SortOrder
    npcId?: SortOrder
    affinity?: SortOrder
    _count?: PlayerRelationshipCountOrderByAggregateInput
    _avg?: PlayerRelationshipAvgOrderByAggregateInput
    _max?: PlayerRelationshipMaxOrderByAggregateInput
    _min?: PlayerRelationshipMinOrderByAggregateInput
    _sum?: PlayerRelationshipSumOrderByAggregateInput
  }

  export type PlayerRelationshipScalarWhereWithAggregatesInput = {
    AND?: PlayerRelationshipScalarWhereWithAggregatesInput | PlayerRelationshipScalarWhereWithAggregatesInput[]
    OR?: PlayerRelationshipScalarWhereWithAggregatesInput[]
    NOT?: PlayerRelationshipScalarWhereWithAggregatesInput | PlayerRelationshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlayerRelationship"> | string
    playerId?: StringWithAggregatesFilter<"PlayerRelationship"> | string
    npcId?: StringWithAggregatesFilter<"PlayerRelationship"> | string
    affinity?: IntWithAggregatesFilter<"PlayerRelationship"> | number
  }

  export type PlayerCreateInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMask?: MaskCreateNestedOneWithoutCurrentPlayersInput
    masksOwned?: PlayerMaskCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventCreateNestedManyWithoutPlayerInput
    location?: ZoneCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    masksOwned?: PlayerMaskUncheckedCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemUncheckedCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameUncheckedCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMask?: MaskUpdateOneWithoutCurrentPlayersNestedInput
    masksOwned?: PlayerMaskUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUpdateManyWithoutPlayerNestedInput
    location?: ZoneUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masksOwned?: PlayerMaskUncheckedUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUncheckedUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUncheckedUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaskCreateInput = {
    id: string
    name: string
    alias: string
    description: string
    personality: string
    corruption?: number
    abilities: JsonNullValueInput | InputJsonValue
    dailyEffects: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskCreatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskCreateunlockRequirementsInput | string[]
    image: string
    symbol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerMaskCreateNestedManyWithoutMaskInput
    currentPlayers?: PlayerCreateNestedManyWithoutCurrentMaskInput
  }

  export type MaskUncheckedCreateInput = {
    id: string
    name: string
    alias: string
    description: string
    personality: string
    corruption?: number
    abilities: JsonNullValueInput | InputJsonValue
    dailyEffects: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskCreatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskCreateunlockRequirementsInput | string[]
    image: string
    symbol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerMaskUncheckedCreateNestedManyWithoutMaskInput
    currentPlayers?: PlayerUncheckedCreateNestedManyWithoutCurrentMaskInput
  }

  export type MaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    abilities?: JsonNullValueInput | InputJsonValue
    dailyEffects?: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskUpdatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskUpdateunlockRequirementsInput | string[]
    image?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerMaskUpdateManyWithoutMaskNestedInput
    currentPlayers?: PlayerUpdateManyWithoutCurrentMaskNestedInput
  }

  export type MaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    abilities?: JsonNullValueInput | InputJsonValue
    dailyEffects?: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskUpdatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskUpdateunlockRequirementsInput | string[]
    image?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerMaskUncheckedUpdateManyWithoutMaskNestedInput
    currentPlayers?: PlayerUncheckedUpdateManyWithoutCurrentMaskNestedInput
  }

  export type MaskCreateManyInput = {
    id: string
    name: string
    alias: string
    description: string
    personality: string
    corruption?: number
    abilities: JsonNullValueInput | InputJsonValue
    dailyEffects: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskCreatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskCreateunlockRequirementsInput | string[]
    image: string
    symbol: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    abilities?: JsonNullValueInput | InputJsonValue
    dailyEffects?: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskUpdatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskUpdateunlockRequirementsInput | string[]
    image?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    abilities?: JsonNullValueInput | InputJsonValue
    dailyEffects?: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskUpdatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskUpdateunlockRequirementsInput | string[]
    image?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMaskCreateInput = {
    id?: string
    corruption?: number
    player: PlayerCreateNestedOneWithoutMasksOwnedInput
    mask: MaskCreateNestedOneWithoutPlayersInput
  }

  export type PlayerMaskUncheckedCreateInput = {
    id?: string
    playerId: string
    maskId: string
    corruption?: number
  }

  export type PlayerMaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutMasksOwnedNestedInput
    mask?: MaskUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerMaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    maskId?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerMaskCreateManyInput = {
    id?: string
    playerId: string
    maskId: string
    corruption?: number
  }

  export type PlayerMaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerMaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    maskId?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
  }

  export type NPCCreateInput = {
    id: string
    name: string
    role: string
    traits?: NPCCreatetraitsInput | string[]
    personality: string
    schedule: JsonNullValueInput | InputJsonValue
    relationship?: number
    rumorScore?: number
    reactions: JsonNullValueInput | InputJsonValue
    events?: NPCCreateeventsInput | string[]
    portrait: string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: ZoneCreateNestedOneWithoutNpcsInput
    playerRelationships?: PlayerRelationshipCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateInput = {
    id: string
    name: string
    role: string
    traits?: NPCCreatetraitsInput | string[]
    personality: string
    schedule: JsonNullValueInput | InputJsonValue
    relationship?: number
    rumorScore?: number
    reactions: JsonNullValueInput | InputJsonValue
    events?: NPCCreateeventsInput | string[]
    portrait: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    playerRelationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: ZoneUpdateOneWithoutNpcsNestedInput
    playerRelationships?: PlayerRelationshipUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerRelationships?: PlayerRelationshipUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type NPCCreateManyInput = {
    id: string
    name: string
    role: string
    traits?: NPCCreatetraitsInput | string[]
    personality: string
    schedule: JsonNullValueInput | InputJsonValue
    relationship?: number
    rumorScore?: number
    reactions: JsonNullValueInput | InputJsonValue
    events?: NPCCreateeventsInput | string[]
    portrait: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NPCUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NPCUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    npcs?: NPCCreateNestedManyWithoutLocationInput
    players?: PlayerCreateNestedManyWithoutLocationInput
    events?: EventCreateNestedManyWithoutZoneInput
    actions?: ActionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    npcs?: NPCUncheckedCreateNestedManyWithoutLocationInput
    players?: PlayerUncheckedCreateNestedManyWithoutLocationInput
    events?: EventUncheckedCreateNestedManyWithoutZoneInput
    actions?: ActionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcs?: NPCUpdateManyWithoutLocationNestedInput
    players?: PlayerUpdateManyWithoutLocationNestedInput
    events?: EventUpdateManyWithoutZoneNestedInput
    actions?: ActionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcs?: NPCUncheckedUpdateManyWithoutLocationNestedInput
    players?: PlayerUncheckedUpdateManyWithoutLocationNestedInput
    events?: EventUncheckedUpdateManyWithoutZoneNestedInput
    actions?: ActionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id: string
    name: string
    type: string
    description: string
    effects: JsonNullValueInput | InputJsonValue
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerItemCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id: string
    name: string
    type: string
    description: string
    effects: JsonNullValueInput | InputJsonValue
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    effects?: JsonNullValueInput | InputJsonValue
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerItemUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    effects?: JsonNullValueInput | InputJsonValue
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id: string
    name: string
    type: string
    description: string
    effects: JsonNullValueInput | InputJsonValue
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    effects?: JsonNullValueInput | InputJsonValue
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    effects?: JsonNullValueInput | InputJsonValue
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerItemCreateInput = {
    id?: string
    quantity?: number
    player: PlayerCreateNestedOneWithoutInventoryInput
    item: ItemCreateNestedOneWithoutPlayersInput
  }

  export type PlayerItemUncheckedCreateInput = {
    id?: string
    playerId: string
    itemId: string
    quantity?: number
  }

  export type PlayerItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutInventoryNestedInput
    item?: ItemUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerItemCreateManyInput = {
    id?: string
    playerId: string
    itemId: string
    quantity?: number
  }

  export type PlayerItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type MinigameCreateInput = {
    id: string
    classId: string
    name: string
    description: string
    difficulty: number
    maskModifiers: JsonNullValueInput | InputJsonValue
    rewards: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    playerProgress?: PlayerMinigameCreateNestedManyWithoutMinigameInput
  }

  export type MinigameUncheckedCreateInput = {
    id: string
    classId: string
    name: string
    description: string
    difficulty: number
    maskModifiers: JsonNullValueInput | InputJsonValue
    rewards: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    playerProgress?: PlayerMinigameUncheckedCreateNestedManyWithoutMinigameInput
  }

  export type MinigameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    maskModifiers?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerProgress?: PlayerMinigameUpdateManyWithoutMinigameNestedInput
  }

  export type MinigameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    maskModifiers?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerProgress?: PlayerMinigameUncheckedUpdateManyWithoutMinigameNestedInput
  }

  export type MinigameCreateManyInput = {
    id: string
    classId: string
    name: string
    description: string
    difficulty: number
    maskModifiers: JsonNullValueInput | InputJsonValue
    rewards: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinigameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    maskModifiers?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinigameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    maskModifiers?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMinigameCreateInput = {
    id?: string
    score?: number
    completed?: boolean
    player: PlayerCreateNestedOneWithoutMinigameProgressInput
    minigame: MinigameCreateNestedOneWithoutPlayerProgressInput
  }

  export type PlayerMinigameUncheckedCreateInput = {
    id?: string
    playerId: string
    minigameId: string
    score?: number
    completed?: boolean
  }

  export type PlayerMinigameUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneRequiredWithoutMinigameProgressNestedInput
    minigame?: MinigameUpdateOneRequiredWithoutPlayerProgressNestedInput
  }

  export type PlayerMinigameUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    minigameId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerMinigameCreateManyInput = {
    id?: string
    playerId: string
    minigameId: string
    score?: number
    completed?: boolean
  }

  export type PlayerMinigameUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerMinigameUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    minigameId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EventCreateInput = {
    id: string
    name: string
    triggerChance: number
    triggerZones?: EventCreatetriggerZonesInput | string[]
    maskModifiers: JsonNullValueInput | InputJsonValue
    choices: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    zone?: ZoneCreateNestedOneWithoutEventsInput
    players?: PlayerEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id: string
    name: string
    triggerChance: number
    triggerZones?: EventCreatetriggerZonesInput | string[]
    maskModifiers: JsonNullValueInput | InputJsonValue
    choices: JsonNullValueInput | InputJsonValue
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneWithoutEventsNestedInput
    players?: PlayerEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id: string
    name: string
    triggerChance: number
    triggerZones?: EventCreatetriggerZonesInput | string[]
    maskModifiers: JsonNullValueInput | InputJsonValue
    choices: JsonNullValueInput | InputJsonValue
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerEventCreateInput = {
    id?: string
    choiceMade?: string | null
    completed?: boolean
    player: PlayerCreateNestedOneWithoutEventsCompletedInput
    event: EventCreateNestedOneWithoutPlayersInput
  }

  export type PlayerEventUncheckedCreateInput = {
    id?: string
    playerId: string
    eventId: string
    choiceMade?: string | null
    completed?: boolean
  }

  export type PlayerEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneRequiredWithoutEventsCompletedNestedInput
    event?: EventUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEventCreateManyInput = {
    id?: string
    playerId: string
    eventId: string
    choiceMade?: string | null
    completed?: boolean
  }

  export type PlayerEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActionCreateInput = {
    id: string
    name: string
    preconditions: JsonNullValueInput | InputJsonValue
    timeCost: number
    effects: JsonNullValueInput | InputJsonValue
    riskLevel: string
    maskModifiers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    zone?: ZoneCreateNestedOneWithoutActionsInput
  }

  export type ActionUncheckedCreateInput = {
    id: string
    name: string
    zoneId?: string | null
    preconditions: JsonNullValueInput | InputJsonValue
    timeCost: number
    effects: JsonNullValueInput | InputJsonValue
    riskLevel: string
    maskModifiers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    preconditions?: JsonNullValueInput | InputJsonValue
    timeCost?: IntFieldUpdateOperationsInput | number
    effects?: JsonNullValueInput | InputJsonValue
    riskLevel?: StringFieldUpdateOperationsInput | string
    maskModifiers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneWithoutActionsNestedInput
  }

  export type ActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: JsonNullValueInput | InputJsonValue
    timeCost?: IntFieldUpdateOperationsInput | number
    effects?: JsonNullValueInput | InputJsonValue
    riskLevel?: StringFieldUpdateOperationsInput | string
    maskModifiers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionCreateManyInput = {
    id: string
    name: string
    zoneId?: string | null
    preconditions: JsonNullValueInput | InputJsonValue
    timeCost: number
    effects: JsonNullValueInput | InputJsonValue
    riskLevel: string
    maskModifiers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    preconditions?: JsonNullValueInput | InputJsonValue
    timeCost?: IntFieldUpdateOperationsInput | number
    effects?: JsonNullValueInput | InputJsonValue
    riskLevel?: StringFieldUpdateOperationsInput | string
    maskModifiers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    preconditions?: JsonNullValueInput | InputJsonValue
    timeCost?: IntFieldUpdateOperationsInput | number
    effects?: JsonNullValueInput | InputJsonValue
    riskLevel?: StringFieldUpdateOperationsInput | string
    maskModifiers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerRelationshipCreateInput = {
    id?: string
    affinity?: number
    player: PlayerCreateNestedOneWithoutRelationshipsInput
    npc: NPCCreateNestedOneWithoutPlayerRelationshipsInput
  }

  export type PlayerRelationshipUncheckedCreateInput = {
    id?: string
    playerId: string
    npcId: string
    affinity?: number
  }

  export type PlayerRelationshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutRelationshipsNestedInput
    npc?: NPCUpdateOneRequiredWithoutPlayerRelationshipsNestedInput
  }

  export type PlayerRelationshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerRelationshipCreateManyInput = {
    id?: string
    playerId: string
    npcId: string
    affinity?: number
  }

  export type PlayerRelationshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerRelationshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MaskNullableRelationFilter = {
    is?: MaskWhereInput | null
    isNot?: MaskWhereInput | null
  }

  export type PlayerMaskListRelationFilter = {
    every?: PlayerMaskWhereInput
    some?: PlayerMaskWhereInput
    none?: PlayerMaskWhereInput
  }

  export type PlayerRelationshipListRelationFilter = {
    every?: PlayerRelationshipWhereInput
    some?: PlayerRelationshipWhereInput
    none?: PlayerRelationshipWhereInput
  }

  export type PlayerItemListRelationFilter = {
    every?: PlayerItemWhereInput
    some?: PlayerItemWhereInput
    none?: PlayerItemWhereInput
  }

  export type PlayerMinigameListRelationFilter = {
    every?: PlayerMinigameWhereInput
    some?: PlayerMinigameWhereInput
    none?: PlayerMinigameWhereInput
  }

  export type PlayerEventListRelationFilter = {
    every?: PlayerEventWhereInput
    some?: PlayerEventWhereInput
    none?: PlayerEventWhereInput
  }

  export type ZoneNullableRelationFilter = {
    is?: ZoneWhereInput | null
    isNot?: ZoneWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PlayerMaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerRelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerMinigameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    grade?: SortOrder
    className?: SortOrder
    currentMaskId?: SortOrder
    energy?: SortOrder
    mood?: SortOrder
    time?: SortOrder
    reputation?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerAvgOrderByAggregateInput = {
    grade?: SortOrder
    energy?: SortOrder
    reputation?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    grade?: SortOrder
    className?: SortOrder
    currentMaskId?: SortOrder
    energy?: SortOrder
    mood?: SortOrder
    time?: SortOrder
    reputation?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    avatar?: SortOrder
    grade?: SortOrder
    className?: SortOrder
    currentMaskId?: SortOrder
    energy?: SortOrder
    mood?: SortOrder
    time?: SortOrder
    reputation?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlayerSumOrderByAggregateInput = {
    grade?: SortOrder
    energy?: SortOrder
    reputation?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    personality?: SortOrder
    corruption?: SortOrder
    abilities?: SortOrder
    dailyEffects?: SortOrder
    corruptionTriggers?: SortOrder
    unlockRequirements?: SortOrder
    image?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaskAvgOrderByAggregateInput = {
    corruption?: SortOrder
  }

  export type MaskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    personality?: SortOrder
    corruption?: SortOrder
    image?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    alias?: SortOrder
    description?: SortOrder
    personality?: SortOrder
    corruption?: SortOrder
    image?: SortOrder
    symbol?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaskSumOrderByAggregateInput = {
    corruption?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PlayerRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type MaskRelationFilter = {
    is?: MaskWhereInput
    isNot?: MaskWhereInput
  }

  export type PlayerMaskPlayerIdMaskIdCompoundUniqueInput = {
    playerId: string
    maskId: string
  }

  export type PlayerMaskCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    maskId?: SortOrder
    corruption?: SortOrder
  }

  export type PlayerMaskAvgOrderByAggregateInput = {
    corruption?: SortOrder
  }

  export type PlayerMaskMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    maskId?: SortOrder
    corruption?: SortOrder
  }

  export type PlayerMaskMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    maskId?: SortOrder
    corruption?: SortOrder
  }

  export type PlayerMaskSumOrderByAggregateInput = {
    corruption?: SortOrder
  }

  export type NPCCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    traits?: SortOrder
    personality?: SortOrder
    schedule?: SortOrder
    relationship?: SortOrder
    rumorScore?: SortOrder
    reactions?: SortOrder
    events?: SortOrder
    portrait?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NPCAvgOrderByAggregateInput = {
    relationship?: SortOrder
    rumorScore?: SortOrder
  }

  export type NPCMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    personality?: SortOrder
    relationship?: SortOrder
    rumorScore?: SortOrder
    portrait?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NPCMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    personality?: SortOrder
    relationship?: SortOrder
    rumorScore?: SortOrder
    portrait?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NPCSumOrderByAggregateInput = {
    relationship?: SortOrder
    rumorScore?: SortOrder
  }

  export type NPCListRelationFilter = {
    every?: NPCWhereInput
    some?: NPCWhereInput
    none?: NPCWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type ActionListRelationFilter = {
    every?: ActionWhereInput
    some?: ActionWhereInput
    none?: ActionWhereInput
  }

  export type NPCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    effects?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type PlayerItemPlayerIdItemIdCompoundUniqueInput = {
    playerId: string
    itemId: string
  }

  export type PlayerItemCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type PlayerItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PlayerItemMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type PlayerItemMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
  }

  export type PlayerItemSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type MinigameCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    maskModifiers?: SortOrder
    rewards?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MinigameAvgOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type MinigameMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MinigameMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MinigameSumOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type MinigameRelationFilter = {
    is?: MinigameWhereInput
    isNot?: MinigameWhereInput
  }

  export type PlayerMinigamePlayerIdMinigameIdCompoundUniqueInput = {
    playerId: string
    minigameId: string
  }

  export type PlayerMinigameCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    minigameId?: SortOrder
    score?: SortOrder
    completed?: SortOrder
  }

  export type PlayerMinigameAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type PlayerMinigameMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    minigameId?: SortOrder
    score?: SortOrder
    completed?: SortOrder
  }

  export type PlayerMinigameMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    minigameId?: SortOrder
    score?: SortOrder
    completed?: SortOrder
  }

  export type PlayerMinigameSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    triggerChance?: SortOrder
    triggerZones?: SortOrder
    maskModifiers?: SortOrder
    choices?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    triggerChance?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    triggerChance?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    triggerChance?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    triggerChance?: SortOrder
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type PlayerEventPlayerIdEventIdCompoundUniqueInput = {
    playerId: string
    eventId: string
  }

  export type PlayerEventCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    eventId?: SortOrder
    choiceMade?: SortOrder
    completed?: SortOrder
  }

  export type PlayerEventMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    eventId?: SortOrder
    choiceMade?: SortOrder
    completed?: SortOrder
  }

  export type PlayerEventMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    eventId?: SortOrder
    choiceMade?: SortOrder
    completed?: SortOrder
  }

  export type ActionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrder
    preconditions?: SortOrder
    timeCost?: SortOrder
    effects?: SortOrder
    riskLevel?: SortOrder
    maskModifiers?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionAvgOrderByAggregateInput = {
    timeCost?: SortOrder
  }

  export type ActionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrder
    timeCost?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zoneId?: SortOrder
    timeCost?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionSumOrderByAggregateInput = {
    timeCost?: SortOrder
  }

  export type NPCRelationFilter = {
    is?: NPCWhereInput
    isNot?: NPCWhereInput
  }

  export type PlayerRelationshipPlayerIdNpcIdCompoundUniqueInput = {
    playerId: string
    npcId: string
  }

  export type PlayerRelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    npcId?: SortOrder
    affinity?: SortOrder
  }

  export type PlayerRelationshipAvgOrderByAggregateInput = {
    affinity?: SortOrder
  }

  export type PlayerRelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    npcId?: SortOrder
    affinity?: SortOrder
  }

  export type PlayerRelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    playerId?: SortOrder
    npcId?: SortOrder
    affinity?: SortOrder
  }

  export type PlayerRelationshipSumOrderByAggregateInput = {
    affinity?: SortOrder
  }

  export type MaskCreateNestedOneWithoutCurrentPlayersInput = {
    create?: XOR<MaskCreateWithoutCurrentPlayersInput, MaskUncheckedCreateWithoutCurrentPlayersInput>
    connectOrCreate?: MaskCreateOrConnectWithoutCurrentPlayersInput
    connect?: MaskWhereUniqueInput
  }

  export type PlayerMaskCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerMaskCreateWithoutPlayerInput, PlayerMaskUncheckedCreateWithoutPlayerInput> | PlayerMaskCreateWithoutPlayerInput[] | PlayerMaskUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerMaskCreateOrConnectWithoutPlayerInput | PlayerMaskCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerMaskCreateManyPlayerInputEnvelope
    connect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
  }

  export type PlayerRelationshipCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerRelationshipCreateWithoutPlayerInput, PlayerRelationshipUncheckedCreateWithoutPlayerInput> | PlayerRelationshipCreateWithoutPlayerInput[] | PlayerRelationshipUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerRelationshipCreateOrConnectWithoutPlayerInput | PlayerRelationshipCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerRelationshipCreateManyPlayerInputEnvelope
    connect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
  }

  export type PlayerItemCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerItemCreateWithoutPlayerInput, PlayerItemUncheckedCreateWithoutPlayerInput> | PlayerItemCreateWithoutPlayerInput[] | PlayerItemUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerItemCreateOrConnectWithoutPlayerInput | PlayerItemCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerItemCreateManyPlayerInputEnvelope
    connect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
  }

  export type PlayerMinigameCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerMinigameCreateWithoutPlayerInput, PlayerMinigameUncheckedCreateWithoutPlayerInput> | PlayerMinigameCreateWithoutPlayerInput[] | PlayerMinigameUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerMinigameCreateOrConnectWithoutPlayerInput | PlayerMinigameCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerMinigameCreateManyPlayerInputEnvelope
    connect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
  }

  export type PlayerEventCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerEventCreateWithoutPlayerInput, PlayerEventUncheckedCreateWithoutPlayerInput> | PlayerEventCreateWithoutPlayerInput[] | PlayerEventUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEventCreateOrConnectWithoutPlayerInput | PlayerEventCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerEventCreateManyPlayerInputEnvelope
    connect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
  }

  export type ZoneCreateNestedOneWithoutPlayersInput = {
    create?: XOR<ZoneCreateWithoutPlayersInput, ZoneUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutPlayersInput
    connect?: ZoneWhereUniqueInput
  }

  export type PlayerMaskUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerMaskCreateWithoutPlayerInput, PlayerMaskUncheckedCreateWithoutPlayerInput> | PlayerMaskCreateWithoutPlayerInput[] | PlayerMaskUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerMaskCreateOrConnectWithoutPlayerInput | PlayerMaskCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerMaskCreateManyPlayerInputEnvelope
    connect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
  }

  export type PlayerRelationshipUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerRelationshipCreateWithoutPlayerInput, PlayerRelationshipUncheckedCreateWithoutPlayerInput> | PlayerRelationshipCreateWithoutPlayerInput[] | PlayerRelationshipUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerRelationshipCreateOrConnectWithoutPlayerInput | PlayerRelationshipCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerRelationshipCreateManyPlayerInputEnvelope
    connect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
  }

  export type PlayerItemUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerItemCreateWithoutPlayerInput, PlayerItemUncheckedCreateWithoutPlayerInput> | PlayerItemCreateWithoutPlayerInput[] | PlayerItemUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerItemCreateOrConnectWithoutPlayerInput | PlayerItemCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerItemCreateManyPlayerInputEnvelope
    connect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
  }

  export type PlayerMinigameUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerMinigameCreateWithoutPlayerInput, PlayerMinigameUncheckedCreateWithoutPlayerInput> | PlayerMinigameCreateWithoutPlayerInput[] | PlayerMinigameUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerMinigameCreateOrConnectWithoutPlayerInput | PlayerMinigameCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerMinigameCreateManyPlayerInputEnvelope
    connect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
  }

  export type PlayerEventUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PlayerEventCreateWithoutPlayerInput, PlayerEventUncheckedCreateWithoutPlayerInput> | PlayerEventCreateWithoutPlayerInput[] | PlayerEventUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEventCreateOrConnectWithoutPlayerInput | PlayerEventCreateOrConnectWithoutPlayerInput[]
    createMany?: PlayerEventCreateManyPlayerInputEnvelope
    connect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MaskUpdateOneWithoutCurrentPlayersNestedInput = {
    create?: XOR<MaskCreateWithoutCurrentPlayersInput, MaskUncheckedCreateWithoutCurrentPlayersInput>
    connectOrCreate?: MaskCreateOrConnectWithoutCurrentPlayersInput
    upsert?: MaskUpsertWithoutCurrentPlayersInput
    disconnect?: MaskWhereInput | boolean
    delete?: MaskWhereInput | boolean
    connect?: MaskWhereUniqueInput
    update?: XOR<XOR<MaskUpdateToOneWithWhereWithoutCurrentPlayersInput, MaskUpdateWithoutCurrentPlayersInput>, MaskUncheckedUpdateWithoutCurrentPlayersInput>
  }

  export type PlayerMaskUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerMaskCreateWithoutPlayerInput, PlayerMaskUncheckedCreateWithoutPlayerInput> | PlayerMaskCreateWithoutPlayerInput[] | PlayerMaskUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerMaskCreateOrConnectWithoutPlayerInput | PlayerMaskCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerMaskUpsertWithWhereUniqueWithoutPlayerInput | PlayerMaskUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerMaskCreateManyPlayerInputEnvelope
    set?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    disconnect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    delete?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    connect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    update?: PlayerMaskUpdateWithWhereUniqueWithoutPlayerInput | PlayerMaskUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerMaskUpdateManyWithWhereWithoutPlayerInput | PlayerMaskUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerMaskScalarWhereInput | PlayerMaskScalarWhereInput[]
  }

  export type PlayerRelationshipUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerRelationshipCreateWithoutPlayerInput, PlayerRelationshipUncheckedCreateWithoutPlayerInput> | PlayerRelationshipCreateWithoutPlayerInput[] | PlayerRelationshipUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerRelationshipCreateOrConnectWithoutPlayerInput | PlayerRelationshipCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerRelationshipUpsertWithWhereUniqueWithoutPlayerInput | PlayerRelationshipUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerRelationshipCreateManyPlayerInputEnvelope
    set?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    disconnect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    delete?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    connect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    update?: PlayerRelationshipUpdateWithWhereUniqueWithoutPlayerInput | PlayerRelationshipUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerRelationshipUpdateManyWithWhereWithoutPlayerInput | PlayerRelationshipUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerRelationshipScalarWhereInput | PlayerRelationshipScalarWhereInput[]
  }

  export type PlayerItemUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerItemCreateWithoutPlayerInput, PlayerItemUncheckedCreateWithoutPlayerInput> | PlayerItemCreateWithoutPlayerInput[] | PlayerItemUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerItemCreateOrConnectWithoutPlayerInput | PlayerItemCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerItemUpsertWithWhereUniqueWithoutPlayerInput | PlayerItemUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerItemCreateManyPlayerInputEnvelope
    set?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    disconnect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    delete?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    connect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    update?: PlayerItemUpdateWithWhereUniqueWithoutPlayerInput | PlayerItemUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerItemUpdateManyWithWhereWithoutPlayerInput | PlayerItemUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerItemScalarWhereInput | PlayerItemScalarWhereInput[]
  }

  export type PlayerMinigameUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerMinigameCreateWithoutPlayerInput, PlayerMinigameUncheckedCreateWithoutPlayerInput> | PlayerMinigameCreateWithoutPlayerInput[] | PlayerMinigameUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerMinigameCreateOrConnectWithoutPlayerInput | PlayerMinigameCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerMinigameUpsertWithWhereUniqueWithoutPlayerInput | PlayerMinigameUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerMinigameCreateManyPlayerInputEnvelope
    set?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    disconnect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    delete?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    connect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    update?: PlayerMinigameUpdateWithWhereUniqueWithoutPlayerInput | PlayerMinigameUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerMinigameUpdateManyWithWhereWithoutPlayerInput | PlayerMinigameUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerMinigameScalarWhereInput | PlayerMinigameScalarWhereInput[]
  }

  export type PlayerEventUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerEventCreateWithoutPlayerInput, PlayerEventUncheckedCreateWithoutPlayerInput> | PlayerEventCreateWithoutPlayerInput[] | PlayerEventUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEventCreateOrConnectWithoutPlayerInput | PlayerEventCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerEventUpsertWithWhereUniqueWithoutPlayerInput | PlayerEventUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerEventCreateManyPlayerInputEnvelope
    set?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    disconnect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    delete?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    connect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    update?: PlayerEventUpdateWithWhereUniqueWithoutPlayerInput | PlayerEventUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerEventUpdateManyWithWhereWithoutPlayerInput | PlayerEventUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerEventScalarWhereInput | PlayerEventScalarWhereInput[]
  }

  export type ZoneUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<ZoneCreateWithoutPlayersInput, ZoneUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutPlayersInput
    upsert?: ZoneUpsertWithoutPlayersInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutPlayersInput, ZoneUpdateWithoutPlayersInput>, ZoneUncheckedUpdateWithoutPlayersInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PlayerMaskUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerMaskCreateWithoutPlayerInput, PlayerMaskUncheckedCreateWithoutPlayerInput> | PlayerMaskCreateWithoutPlayerInput[] | PlayerMaskUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerMaskCreateOrConnectWithoutPlayerInput | PlayerMaskCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerMaskUpsertWithWhereUniqueWithoutPlayerInput | PlayerMaskUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerMaskCreateManyPlayerInputEnvelope
    set?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    disconnect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    delete?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    connect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    update?: PlayerMaskUpdateWithWhereUniqueWithoutPlayerInput | PlayerMaskUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerMaskUpdateManyWithWhereWithoutPlayerInput | PlayerMaskUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerMaskScalarWhereInput | PlayerMaskScalarWhereInput[]
  }

  export type PlayerRelationshipUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerRelationshipCreateWithoutPlayerInput, PlayerRelationshipUncheckedCreateWithoutPlayerInput> | PlayerRelationshipCreateWithoutPlayerInput[] | PlayerRelationshipUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerRelationshipCreateOrConnectWithoutPlayerInput | PlayerRelationshipCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerRelationshipUpsertWithWhereUniqueWithoutPlayerInput | PlayerRelationshipUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerRelationshipCreateManyPlayerInputEnvelope
    set?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    disconnect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    delete?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    connect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    update?: PlayerRelationshipUpdateWithWhereUniqueWithoutPlayerInput | PlayerRelationshipUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerRelationshipUpdateManyWithWhereWithoutPlayerInput | PlayerRelationshipUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerRelationshipScalarWhereInput | PlayerRelationshipScalarWhereInput[]
  }

  export type PlayerItemUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerItemCreateWithoutPlayerInput, PlayerItemUncheckedCreateWithoutPlayerInput> | PlayerItemCreateWithoutPlayerInput[] | PlayerItemUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerItemCreateOrConnectWithoutPlayerInput | PlayerItemCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerItemUpsertWithWhereUniqueWithoutPlayerInput | PlayerItemUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerItemCreateManyPlayerInputEnvelope
    set?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    disconnect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    delete?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    connect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    update?: PlayerItemUpdateWithWhereUniqueWithoutPlayerInput | PlayerItemUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerItemUpdateManyWithWhereWithoutPlayerInput | PlayerItemUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerItemScalarWhereInput | PlayerItemScalarWhereInput[]
  }

  export type PlayerMinigameUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerMinigameCreateWithoutPlayerInput, PlayerMinigameUncheckedCreateWithoutPlayerInput> | PlayerMinigameCreateWithoutPlayerInput[] | PlayerMinigameUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerMinigameCreateOrConnectWithoutPlayerInput | PlayerMinigameCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerMinigameUpsertWithWhereUniqueWithoutPlayerInput | PlayerMinigameUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerMinigameCreateManyPlayerInputEnvelope
    set?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    disconnect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    delete?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    connect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    update?: PlayerMinigameUpdateWithWhereUniqueWithoutPlayerInput | PlayerMinigameUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerMinigameUpdateManyWithWhereWithoutPlayerInput | PlayerMinigameUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerMinigameScalarWhereInput | PlayerMinigameScalarWhereInput[]
  }

  export type PlayerEventUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PlayerEventCreateWithoutPlayerInput, PlayerEventUncheckedCreateWithoutPlayerInput> | PlayerEventCreateWithoutPlayerInput[] | PlayerEventUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PlayerEventCreateOrConnectWithoutPlayerInput | PlayerEventCreateOrConnectWithoutPlayerInput[]
    upsert?: PlayerEventUpsertWithWhereUniqueWithoutPlayerInput | PlayerEventUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PlayerEventCreateManyPlayerInputEnvelope
    set?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    disconnect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    delete?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    connect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    update?: PlayerEventUpdateWithWhereUniqueWithoutPlayerInput | PlayerEventUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PlayerEventUpdateManyWithWhereWithoutPlayerInput | PlayerEventUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PlayerEventScalarWhereInput | PlayerEventScalarWhereInput[]
  }

  export type MaskCreatecorruptionTriggersInput = {
    set: string[]
  }

  export type MaskCreateunlockRequirementsInput = {
    set: string[]
  }

  export type PlayerMaskCreateNestedManyWithoutMaskInput = {
    create?: XOR<PlayerMaskCreateWithoutMaskInput, PlayerMaskUncheckedCreateWithoutMaskInput> | PlayerMaskCreateWithoutMaskInput[] | PlayerMaskUncheckedCreateWithoutMaskInput[]
    connectOrCreate?: PlayerMaskCreateOrConnectWithoutMaskInput | PlayerMaskCreateOrConnectWithoutMaskInput[]
    createMany?: PlayerMaskCreateManyMaskInputEnvelope
    connect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutCurrentMaskInput = {
    create?: XOR<PlayerCreateWithoutCurrentMaskInput, PlayerUncheckedCreateWithoutCurrentMaskInput> | PlayerCreateWithoutCurrentMaskInput[] | PlayerUncheckedCreateWithoutCurrentMaskInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutCurrentMaskInput | PlayerCreateOrConnectWithoutCurrentMaskInput[]
    createMany?: PlayerCreateManyCurrentMaskInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type PlayerMaskUncheckedCreateNestedManyWithoutMaskInput = {
    create?: XOR<PlayerMaskCreateWithoutMaskInput, PlayerMaskUncheckedCreateWithoutMaskInput> | PlayerMaskCreateWithoutMaskInput[] | PlayerMaskUncheckedCreateWithoutMaskInput[]
    connectOrCreate?: PlayerMaskCreateOrConnectWithoutMaskInput | PlayerMaskCreateOrConnectWithoutMaskInput[]
    createMany?: PlayerMaskCreateManyMaskInputEnvelope
    connect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutCurrentMaskInput = {
    create?: XOR<PlayerCreateWithoutCurrentMaskInput, PlayerUncheckedCreateWithoutCurrentMaskInput> | PlayerCreateWithoutCurrentMaskInput[] | PlayerUncheckedCreateWithoutCurrentMaskInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutCurrentMaskInput | PlayerCreateOrConnectWithoutCurrentMaskInput[]
    createMany?: PlayerCreateManyCurrentMaskInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type MaskUpdatecorruptionTriggersInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MaskUpdateunlockRequirementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlayerMaskUpdateManyWithoutMaskNestedInput = {
    create?: XOR<PlayerMaskCreateWithoutMaskInput, PlayerMaskUncheckedCreateWithoutMaskInput> | PlayerMaskCreateWithoutMaskInput[] | PlayerMaskUncheckedCreateWithoutMaskInput[]
    connectOrCreate?: PlayerMaskCreateOrConnectWithoutMaskInput | PlayerMaskCreateOrConnectWithoutMaskInput[]
    upsert?: PlayerMaskUpsertWithWhereUniqueWithoutMaskInput | PlayerMaskUpsertWithWhereUniqueWithoutMaskInput[]
    createMany?: PlayerMaskCreateManyMaskInputEnvelope
    set?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    disconnect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    delete?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    connect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    update?: PlayerMaskUpdateWithWhereUniqueWithoutMaskInput | PlayerMaskUpdateWithWhereUniqueWithoutMaskInput[]
    updateMany?: PlayerMaskUpdateManyWithWhereWithoutMaskInput | PlayerMaskUpdateManyWithWhereWithoutMaskInput[]
    deleteMany?: PlayerMaskScalarWhereInput | PlayerMaskScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutCurrentMaskNestedInput = {
    create?: XOR<PlayerCreateWithoutCurrentMaskInput, PlayerUncheckedCreateWithoutCurrentMaskInput> | PlayerCreateWithoutCurrentMaskInput[] | PlayerUncheckedCreateWithoutCurrentMaskInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutCurrentMaskInput | PlayerCreateOrConnectWithoutCurrentMaskInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutCurrentMaskInput | PlayerUpsertWithWhereUniqueWithoutCurrentMaskInput[]
    createMany?: PlayerCreateManyCurrentMaskInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutCurrentMaskInput | PlayerUpdateWithWhereUniqueWithoutCurrentMaskInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutCurrentMaskInput | PlayerUpdateManyWithWhereWithoutCurrentMaskInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerMaskUncheckedUpdateManyWithoutMaskNestedInput = {
    create?: XOR<PlayerMaskCreateWithoutMaskInput, PlayerMaskUncheckedCreateWithoutMaskInput> | PlayerMaskCreateWithoutMaskInput[] | PlayerMaskUncheckedCreateWithoutMaskInput[]
    connectOrCreate?: PlayerMaskCreateOrConnectWithoutMaskInput | PlayerMaskCreateOrConnectWithoutMaskInput[]
    upsert?: PlayerMaskUpsertWithWhereUniqueWithoutMaskInput | PlayerMaskUpsertWithWhereUniqueWithoutMaskInput[]
    createMany?: PlayerMaskCreateManyMaskInputEnvelope
    set?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    disconnect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    delete?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    connect?: PlayerMaskWhereUniqueInput | PlayerMaskWhereUniqueInput[]
    update?: PlayerMaskUpdateWithWhereUniqueWithoutMaskInput | PlayerMaskUpdateWithWhereUniqueWithoutMaskInput[]
    updateMany?: PlayerMaskUpdateManyWithWhereWithoutMaskInput | PlayerMaskUpdateManyWithWhereWithoutMaskInput[]
    deleteMany?: PlayerMaskScalarWhereInput | PlayerMaskScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutCurrentMaskNestedInput = {
    create?: XOR<PlayerCreateWithoutCurrentMaskInput, PlayerUncheckedCreateWithoutCurrentMaskInput> | PlayerCreateWithoutCurrentMaskInput[] | PlayerUncheckedCreateWithoutCurrentMaskInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutCurrentMaskInput | PlayerCreateOrConnectWithoutCurrentMaskInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutCurrentMaskInput | PlayerUpsertWithWhereUniqueWithoutCurrentMaskInput[]
    createMany?: PlayerCreateManyCurrentMaskInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutCurrentMaskInput | PlayerUpdateWithWhereUniqueWithoutCurrentMaskInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutCurrentMaskInput | PlayerUpdateManyWithWhereWithoutCurrentMaskInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutMasksOwnedInput = {
    create?: XOR<PlayerCreateWithoutMasksOwnedInput, PlayerUncheckedCreateWithoutMasksOwnedInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMasksOwnedInput
    connect?: PlayerWhereUniqueInput
  }

  export type MaskCreateNestedOneWithoutPlayersInput = {
    create?: XOR<MaskCreateWithoutPlayersInput, MaskUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: MaskCreateOrConnectWithoutPlayersInput
    connect?: MaskWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutMasksOwnedNestedInput = {
    create?: XOR<PlayerCreateWithoutMasksOwnedInput, PlayerUncheckedCreateWithoutMasksOwnedInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMasksOwnedInput
    upsert?: PlayerUpsertWithoutMasksOwnedInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMasksOwnedInput, PlayerUpdateWithoutMasksOwnedInput>, PlayerUncheckedUpdateWithoutMasksOwnedInput>
  }

  export type MaskUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<MaskCreateWithoutPlayersInput, MaskUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: MaskCreateOrConnectWithoutPlayersInput
    upsert?: MaskUpsertWithoutPlayersInput
    connect?: MaskWhereUniqueInput
    update?: XOR<XOR<MaskUpdateToOneWithWhereWithoutPlayersInput, MaskUpdateWithoutPlayersInput>, MaskUncheckedUpdateWithoutPlayersInput>
  }

  export type NPCCreatetraitsInput = {
    set: string[]
  }

  export type NPCCreateeventsInput = {
    set: string[]
  }

  export type ZoneCreateNestedOneWithoutNpcsInput = {
    create?: XOR<ZoneCreateWithoutNpcsInput, ZoneUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutNpcsInput
    connect?: ZoneWhereUniqueInput
  }

  export type PlayerRelationshipCreateNestedManyWithoutNpcInput = {
    create?: XOR<PlayerRelationshipCreateWithoutNpcInput, PlayerRelationshipUncheckedCreateWithoutNpcInput> | PlayerRelationshipCreateWithoutNpcInput[] | PlayerRelationshipUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: PlayerRelationshipCreateOrConnectWithoutNpcInput | PlayerRelationshipCreateOrConnectWithoutNpcInput[]
    createMany?: PlayerRelationshipCreateManyNpcInputEnvelope
    connect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
  }

  export type PlayerRelationshipUncheckedCreateNestedManyWithoutNpcInput = {
    create?: XOR<PlayerRelationshipCreateWithoutNpcInput, PlayerRelationshipUncheckedCreateWithoutNpcInput> | PlayerRelationshipCreateWithoutNpcInput[] | PlayerRelationshipUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: PlayerRelationshipCreateOrConnectWithoutNpcInput | PlayerRelationshipCreateOrConnectWithoutNpcInput[]
    createMany?: PlayerRelationshipCreateManyNpcInputEnvelope
    connect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
  }

  export type NPCUpdatetraitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NPCUpdateeventsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ZoneUpdateOneWithoutNpcsNestedInput = {
    create?: XOR<ZoneCreateWithoutNpcsInput, ZoneUncheckedCreateWithoutNpcsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutNpcsInput
    upsert?: ZoneUpsertWithoutNpcsInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutNpcsInput, ZoneUpdateWithoutNpcsInput>, ZoneUncheckedUpdateWithoutNpcsInput>
  }

  export type PlayerRelationshipUpdateManyWithoutNpcNestedInput = {
    create?: XOR<PlayerRelationshipCreateWithoutNpcInput, PlayerRelationshipUncheckedCreateWithoutNpcInput> | PlayerRelationshipCreateWithoutNpcInput[] | PlayerRelationshipUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: PlayerRelationshipCreateOrConnectWithoutNpcInput | PlayerRelationshipCreateOrConnectWithoutNpcInput[]
    upsert?: PlayerRelationshipUpsertWithWhereUniqueWithoutNpcInput | PlayerRelationshipUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: PlayerRelationshipCreateManyNpcInputEnvelope
    set?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    disconnect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    delete?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    connect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    update?: PlayerRelationshipUpdateWithWhereUniqueWithoutNpcInput | PlayerRelationshipUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: PlayerRelationshipUpdateManyWithWhereWithoutNpcInput | PlayerRelationshipUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: PlayerRelationshipScalarWhereInput | PlayerRelationshipScalarWhereInput[]
  }

  export type PlayerRelationshipUncheckedUpdateManyWithoutNpcNestedInput = {
    create?: XOR<PlayerRelationshipCreateWithoutNpcInput, PlayerRelationshipUncheckedCreateWithoutNpcInput> | PlayerRelationshipCreateWithoutNpcInput[] | PlayerRelationshipUncheckedCreateWithoutNpcInput[]
    connectOrCreate?: PlayerRelationshipCreateOrConnectWithoutNpcInput | PlayerRelationshipCreateOrConnectWithoutNpcInput[]
    upsert?: PlayerRelationshipUpsertWithWhereUniqueWithoutNpcInput | PlayerRelationshipUpsertWithWhereUniqueWithoutNpcInput[]
    createMany?: PlayerRelationshipCreateManyNpcInputEnvelope
    set?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    disconnect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    delete?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    connect?: PlayerRelationshipWhereUniqueInput | PlayerRelationshipWhereUniqueInput[]
    update?: PlayerRelationshipUpdateWithWhereUniqueWithoutNpcInput | PlayerRelationshipUpdateWithWhereUniqueWithoutNpcInput[]
    updateMany?: PlayerRelationshipUpdateManyWithWhereWithoutNpcInput | PlayerRelationshipUpdateManyWithWhereWithoutNpcInput[]
    deleteMany?: PlayerRelationshipScalarWhereInput | PlayerRelationshipScalarWhereInput[]
  }

  export type NPCCreateNestedManyWithoutLocationInput = {
    create?: XOR<NPCCreateWithoutLocationInput, NPCUncheckedCreateWithoutLocationInput> | NPCCreateWithoutLocationInput[] | NPCUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutLocationInput | NPCCreateOrConnectWithoutLocationInput[]
    createMany?: NPCCreateManyLocationInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutLocationInput = {
    create?: XOR<PlayerCreateWithoutLocationInput, PlayerUncheckedCreateWithoutLocationInput> | PlayerCreateWithoutLocationInput[] | PlayerUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutLocationInput | PlayerCreateOrConnectWithoutLocationInput[]
    createMany?: PlayerCreateManyLocationInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutZoneInput = {
    create?: XOR<EventCreateWithoutZoneInput, EventUncheckedCreateWithoutZoneInput> | EventCreateWithoutZoneInput[] | EventUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EventCreateOrConnectWithoutZoneInput | EventCreateOrConnectWithoutZoneInput[]
    createMany?: EventCreateManyZoneInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ActionCreateNestedManyWithoutZoneInput = {
    create?: XOR<ActionCreateWithoutZoneInput, ActionUncheckedCreateWithoutZoneInput> | ActionCreateWithoutZoneInput[] | ActionUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutZoneInput | ActionCreateOrConnectWithoutZoneInput[]
    createMany?: ActionCreateManyZoneInputEnvelope
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type NPCUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<NPCCreateWithoutLocationInput, NPCUncheckedCreateWithoutLocationInput> | NPCCreateWithoutLocationInput[] | NPCUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutLocationInput | NPCCreateOrConnectWithoutLocationInput[]
    createMany?: NPCCreateManyLocationInputEnvelope
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<PlayerCreateWithoutLocationInput, PlayerUncheckedCreateWithoutLocationInput> | PlayerCreateWithoutLocationInput[] | PlayerUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutLocationInput | PlayerCreateOrConnectWithoutLocationInput[]
    createMany?: PlayerCreateManyLocationInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<EventCreateWithoutZoneInput, EventUncheckedCreateWithoutZoneInput> | EventCreateWithoutZoneInput[] | EventUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EventCreateOrConnectWithoutZoneInput | EventCreateOrConnectWithoutZoneInput[]
    createMany?: EventCreateManyZoneInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ActionUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<ActionCreateWithoutZoneInput, ActionUncheckedCreateWithoutZoneInput> | ActionCreateWithoutZoneInput[] | ActionUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutZoneInput | ActionCreateOrConnectWithoutZoneInput[]
    createMany?: ActionCreateManyZoneInputEnvelope
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
  }

  export type NPCUpdateManyWithoutLocationNestedInput = {
    create?: XOR<NPCCreateWithoutLocationInput, NPCUncheckedCreateWithoutLocationInput> | NPCCreateWithoutLocationInput[] | NPCUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutLocationInput | NPCCreateOrConnectWithoutLocationInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutLocationInput | NPCUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: NPCCreateManyLocationInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutLocationInput | NPCUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutLocationInput | NPCUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PlayerCreateWithoutLocationInput, PlayerUncheckedCreateWithoutLocationInput> | PlayerCreateWithoutLocationInput[] | PlayerUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutLocationInput | PlayerCreateOrConnectWithoutLocationInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutLocationInput | PlayerUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PlayerCreateManyLocationInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutLocationInput | PlayerUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutLocationInput | PlayerUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type EventUpdateManyWithoutZoneNestedInput = {
    create?: XOR<EventCreateWithoutZoneInput, EventUncheckedCreateWithoutZoneInput> | EventCreateWithoutZoneInput[] | EventUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EventCreateOrConnectWithoutZoneInput | EventCreateOrConnectWithoutZoneInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutZoneInput | EventUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: EventCreateManyZoneInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutZoneInput | EventUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: EventUpdateManyWithWhereWithoutZoneInput | EventUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ActionUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ActionCreateWithoutZoneInput, ActionUncheckedCreateWithoutZoneInput> | ActionCreateWithoutZoneInput[] | ActionUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutZoneInput | ActionCreateOrConnectWithoutZoneInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutZoneInput | ActionUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ActionCreateManyZoneInputEnvelope
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutZoneInput | ActionUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutZoneInput | ActionUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type NPCUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<NPCCreateWithoutLocationInput, NPCUncheckedCreateWithoutLocationInput> | NPCCreateWithoutLocationInput[] | NPCUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: NPCCreateOrConnectWithoutLocationInput | NPCCreateOrConnectWithoutLocationInput[]
    upsert?: NPCUpsertWithWhereUniqueWithoutLocationInput | NPCUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: NPCCreateManyLocationInputEnvelope
    set?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    disconnect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    delete?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    connect?: NPCWhereUniqueInput | NPCWhereUniqueInput[]
    update?: NPCUpdateWithWhereUniqueWithoutLocationInput | NPCUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: NPCUpdateManyWithWhereWithoutLocationInput | NPCUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: NPCScalarWhereInput | NPCScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<PlayerCreateWithoutLocationInput, PlayerUncheckedCreateWithoutLocationInput> | PlayerCreateWithoutLocationInput[] | PlayerUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutLocationInput | PlayerCreateOrConnectWithoutLocationInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutLocationInput | PlayerUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: PlayerCreateManyLocationInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutLocationInput | PlayerUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutLocationInput | PlayerUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<EventCreateWithoutZoneInput, EventUncheckedCreateWithoutZoneInput> | EventCreateWithoutZoneInput[] | EventUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EventCreateOrConnectWithoutZoneInput | EventCreateOrConnectWithoutZoneInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutZoneInput | EventUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: EventCreateManyZoneInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutZoneInput | EventUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: EventUpdateManyWithWhereWithoutZoneInput | EventUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ActionUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<ActionCreateWithoutZoneInput, ActionUncheckedCreateWithoutZoneInput> | ActionCreateWithoutZoneInput[] | ActionUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: ActionCreateOrConnectWithoutZoneInput | ActionCreateOrConnectWithoutZoneInput[]
    upsert?: ActionUpsertWithWhereUniqueWithoutZoneInput | ActionUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: ActionCreateManyZoneInputEnvelope
    set?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    disconnect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    delete?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    connect?: ActionWhereUniqueInput | ActionWhereUniqueInput[]
    update?: ActionUpdateWithWhereUniqueWithoutZoneInput | ActionUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: ActionUpdateManyWithWhereWithoutZoneInput | ActionUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: ActionScalarWhereInput | ActionScalarWhereInput[]
  }

  export type PlayerItemCreateNestedManyWithoutItemInput = {
    create?: XOR<PlayerItemCreateWithoutItemInput, PlayerItemUncheckedCreateWithoutItemInput> | PlayerItemCreateWithoutItemInput[] | PlayerItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PlayerItemCreateOrConnectWithoutItemInput | PlayerItemCreateOrConnectWithoutItemInput[]
    createMany?: PlayerItemCreateManyItemInputEnvelope
    connect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
  }

  export type PlayerItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<PlayerItemCreateWithoutItemInput, PlayerItemUncheckedCreateWithoutItemInput> | PlayerItemCreateWithoutItemInput[] | PlayerItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PlayerItemCreateOrConnectWithoutItemInput | PlayerItemCreateOrConnectWithoutItemInput[]
    createMany?: PlayerItemCreateManyItemInputEnvelope
    connect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
  }

  export type PlayerItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<PlayerItemCreateWithoutItemInput, PlayerItemUncheckedCreateWithoutItemInput> | PlayerItemCreateWithoutItemInput[] | PlayerItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PlayerItemCreateOrConnectWithoutItemInput | PlayerItemCreateOrConnectWithoutItemInput[]
    upsert?: PlayerItemUpsertWithWhereUniqueWithoutItemInput | PlayerItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PlayerItemCreateManyItemInputEnvelope
    set?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    disconnect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    delete?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    connect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    update?: PlayerItemUpdateWithWhereUniqueWithoutItemInput | PlayerItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PlayerItemUpdateManyWithWhereWithoutItemInput | PlayerItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PlayerItemScalarWhereInput | PlayerItemScalarWhereInput[]
  }

  export type PlayerItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<PlayerItemCreateWithoutItemInput, PlayerItemUncheckedCreateWithoutItemInput> | PlayerItemCreateWithoutItemInput[] | PlayerItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: PlayerItemCreateOrConnectWithoutItemInput | PlayerItemCreateOrConnectWithoutItemInput[]
    upsert?: PlayerItemUpsertWithWhereUniqueWithoutItemInput | PlayerItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: PlayerItemCreateManyItemInputEnvelope
    set?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    disconnect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    delete?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    connect?: PlayerItemWhereUniqueInput | PlayerItemWhereUniqueInput[]
    update?: PlayerItemUpdateWithWhereUniqueWithoutItemInput | PlayerItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: PlayerItemUpdateManyWithWhereWithoutItemInput | PlayerItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: PlayerItemScalarWhereInput | PlayerItemScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutInventoryInput = {
    create?: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutInventoryInput
    connect?: PlayerWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutPlayersInput = {
    create?: XOR<ItemCreateWithoutPlayersInput, ItemUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPlayersInput
    connect?: ItemWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutInventoryNestedInput = {
    create?: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutInventoryInput
    upsert?: PlayerUpsertWithoutInventoryInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutInventoryInput, PlayerUpdateWithoutInventoryInput>, PlayerUncheckedUpdateWithoutInventoryInput>
  }

  export type ItemUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<ItemCreateWithoutPlayersInput, ItemUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: ItemCreateOrConnectWithoutPlayersInput
    upsert?: ItemUpsertWithoutPlayersInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutPlayersInput, ItemUpdateWithoutPlayersInput>, ItemUncheckedUpdateWithoutPlayersInput>
  }

  export type PlayerMinigameCreateNestedManyWithoutMinigameInput = {
    create?: XOR<PlayerMinigameCreateWithoutMinigameInput, PlayerMinigameUncheckedCreateWithoutMinigameInput> | PlayerMinigameCreateWithoutMinigameInput[] | PlayerMinigameUncheckedCreateWithoutMinigameInput[]
    connectOrCreate?: PlayerMinigameCreateOrConnectWithoutMinigameInput | PlayerMinigameCreateOrConnectWithoutMinigameInput[]
    createMany?: PlayerMinigameCreateManyMinigameInputEnvelope
    connect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
  }

  export type PlayerMinigameUncheckedCreateNestedManyWithoutMinigameInput = {
    create?: XOR<PlayerMinigameCreateWithoutMinigameInput, PlayerMinigameUncheckedCreateWithoutMinigameInput> | PlayerMinigameCreateWithoutMinigameInput[] | PlayerMinigameUncheckedCreateWithoutMinigameInput[]
    connectOrCreate?: PlayerMinigameCreateOrConnectWithoutMinigameInput | PlayerMinigameCreateOrConnectWithoutMinigameInput[]
    createMany?: PlayerMinigameCreateManyMinigameInputEnvelope
    connect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
  }

  export type PlayerMinigameUpdateManyWithoutMinigameNestedInput = {
    create?: XOR<PlayerMinigameCreateWithoutMinigameInput, PlayerMinigameUncheckedCreateWithoutMinigameInput> | PlayerMinigameCreateWithoutMinigameInput[] | PlayerMinigameUncheckedCreateWithoutMinigameInput[]
    connectOrCreate?: PlayerMinigameCreateOrConnectWithoutMinigameInput | PlayerMinigameCreateOrConnectWithoutMinigameInput[]
    upsert?: PlayerMinigameUpsertWithWhereUniqueWithoutMinigameInput | PlayerMinigameUpsertWithWhereUniqueWithoutMinigameInput[]
    createMany?: PlayerMinigameCreateManyMinigameInputEnvelope
    set?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    disconnect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    delete?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    connect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    update?: PlayerMinigameUpdateWithWhereUniqueWithoutMinigameInput | PlayerMinigameUpdateWithWhereUniqueWithoutMinigameInput[]
    updateMany?: PlayerMinigameUpdateManyWithWhereWithoutMinigameInput | PlayerMinigameUpdateManyWithWhereWithoutMinigameInput[]
    deleteMany?: PlayerMinigameScalarWhereInput | PlayerMinigameScalarWhereInput[]
  }

  export type PlayerMinigameUncheckedUpdateManyWithoutMinigameNestedInput = {
    create?: XOR<PlayerMinigameCreateWithoutMinigameInput, PlayerMinigameUncheckedCreateWithoutMinigameInput> | PlayerMinigameCreateWithoutMinigameInput[] | PlayerMinigameUncheckedCreateWithoutMinigameInput[]
    connectOrCreate?: PlayerMinigameCreateOrConnectWithoutMinigameInput | PlayerMinigameCreateOrConnectWithoutMinigameInput[]
    upsert?: PlayerMinigameUpsertWithWhereUniqueWithoutMinigameInput | PlayerMinigameUpsertWithWhereUniqueWithoutMinigameInput[]
    createMany?: PlayerMinigameCreateManyMinigameInputEnvelope
    set?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    disconnect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    delete?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    connect?: PlayerMinigameWhereUniqueInput | PlayerMinigameWhereUniqueInput[]
    update?: PlayerMinigameUpdateWithWhereUniqueWithoutMinigameInput | PlayerMinigameUpdateWithWhereUniqueWithoutMinigameInput[]
    updateMany?: PlayerMinigameUpdateManyWithWhereWithoutMinigameInput | PlayerMinigameUpdateManyWithWhereWithoutMinigameInput[]
    deleteMany?: PlayerMinigameScalarWhereInput | PlayerMinigameScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutMinigameProgressInput = {
    create?: XOR<PlayerCreateWithoutMinigameProgressInput, PlayerUncheckedCreateWithoutMinigameProgressInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMinigameProgressInput
    connect?: PlayerWhereUniqueInput
  }

  export type MinigameCreateNestedOneWithoutPlayerProgressInput = {
    create?: XOR<MinigameCreateWithoutPlayerProgressInput, MinigameUncheckedCreateWithoutPlayerProgressInput>
    connectOrCreate?: MinigameCreateOrConnectWithoutPlayerProgressInput
    connect?: MinigameWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PlayerUpdateOneRequiredWithoutMinigameProgressNestedInput = {
    create?: XOR<PlayerCreateWithoutMinigameProgressInput, PlayerUncheckedCreateWithoutMinigameProgressInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMinigameProgressInput
    upsert?: PlayerUpsertWithoutMinigameProgressInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMinigameProgressInput, PlayerUpdateWithoutMinigameProgressInput>, PlayerUncheckedUpdateWithoutMinigameProgressInput>
  }

  export type MinigameUpdateOneRequiredWithoutPlayerProgressNestedInput = {
    create?: XOR<MinigameCreateWithoutPlayerProgressInput, MinigameUncheckedCreateWithoutPlayerProgressInput>
    connectOrCreate?: MinigameCreateOrConnectWithoutPlayerProgressInput
    upsert?: MinigameUpsertWithoutPlayerProgressInput
    connect?: MinigameWhereUniqueInput
    update?: XOR<XOR<MinigameUpdateToOneWithWhereWithoutPlayerProgressInput, MinigameUpdateWithoutPlayerProgressInput>, MinigameUncheckedUpdateWithoutPlayerProgressInput>
  }

  export type EventCreatetriggerZonesInput = {
    set: string[]
  }

  export type ZoneCreateNestedOneWithoutEventsInput = {
    create?: XOR<ZoneCreateWithoutEventsInput, ZoneUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutEventsInput
    connect?: ZoneWhereUniqueInput
  }

  export type PlayerEventCreateNestedManyWithoutEventInput = {
    create?: XOR<PlayerEventCreateWithoutEventInput, PlayerEventUncheckedCreateWithoutEventInput> | PlayerEventCreateWithoutEventInput[] | PlayerEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: PlayerEventCreateOrConnectWithoutEventInput | PlayerEventCreateOrConnectWithoutEventInput[]
    createMany?: PlayerEventCreateManyEventInputEnvelope
    connect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
  }

  export type PlayerEventUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<PlayerEventCreateWithoutEventInput, PlayerEventUncheckedCreateWithoutEventInput> | PlayerEventCreateWithoutEventInput[] | PlayerEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: PlayerEventCreateOrConnectWithoutEventInput | PlayerEventCreateOrConnectWithoutEventInput[]
    createMany?: PlayerEventCreateManyEventInputEnvelope
    connect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
  }

  export type EventUpdatetriggerZonesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ZoneUpdateOneWithoutEventsNestedInput = {
    create?: XOR<ZoneCreateWithoutEventsInput, ZoneUncheckedCreateWithoutEventsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutEventsInput
    upsert?: ZoneUpsertWithoutEventsInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutEventsInput, ZoneUpdateWithoutEventsInput>, ZoneUncheckedUpdateWithoutEventsInput>
  }

  export type PlayerEventUpdateManyWithoutEventNestedInput = {
    create?: XOR<PlayerEventCreateWithoutEventInput, PlayerEventUncheckedCreateWithoutEventInput> | PlayerEventCreateWithoutEventInput[] | PlayerEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: PlayerEventCreateOrConnectWithoutEventInput | PlayerEventCreateOrConnectWithoutEventInput[]
    upsert?: PlayerEventUpsertWithWhereUniqueWithoutEventInput | PlayerEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: PlayerEventCreateManyEventInputEnvelope
    set?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    disconnect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    delete?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    connect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    update?: PlayerEventUpdateWithWhereUniqueWithoutEventInput | PlayerEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: PlayerEventUpdateManyWithWhereWithoutEventInput | PlayerEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: PlayerEventScalarWhereInput | PlayerEventScalarWhereInput[]
  }

  export type PlayerEventUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<PlayerEventCreateWithoutEventInput, PlayerEventUncheckedCreateWithoutEventInput> | PlayerEventCreateWithoutEventInput[] | PlayerEventUncheckedCreateWithoutEventInput[]
    connectOrCreate?: PlayerEventCreateOrConnectWithoutEventInput | PlayerEventCreateOrConnectWithoutEventInput[]
    upsert?: PlayerEventUpsertWithWhereUniqueWithoutEventInput | PlayerEventUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: PlayerEventCreateManyEventInputEnvelope
    set?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    disconnect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    delete?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    connect?: PlayerEventWhereUniqueInput | PlayerEventWhereUniqueInput[]
    update?: PlayerEventUpdateWithWhereUniqueWithoutEventInput | PlayerEventUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: PlayerEventUpdateManyWithWhereWithoutEventInput | PlayerEventUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: PlayerEventScalarWhereInput | PlayerEventScalarWhereInput[]
  }

  export type PlayerCreateNestedOneWithoutEventsCompletedInput = {
    create?: XOR<PlayerCreateWithoutEventsCompletedInput, PlayerUncheckedCreateWithoutEventsCompletedInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEventsCompletedInput
    connect?: PlayerWhereUniqueInput
  }

  export type EventCreateNestedOneWithoutPlayersInput = {
    create?: XOR<EventCreateWithoutPlayersInput, EventUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: EventCreateOrConnectWithoutPlayersInput
    connect?: EventWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutEventsCompletedNestedInput = {
    create?: XOR<PlayerCreateWithoutEventsCompletedInput, PlayerUncheckedCreateWithoutEventsCompletedInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutEventsCompletedInput
    upsert?: PlayerUpsertWithoutEventsCompletedInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutEventsCompletedInput, PlayerUpdateWithoutEventsCompletedInput>, PlayerUncheckedUpdateWithoutEventsCompletedInput>
  }

  export type EventUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<EventCreateWithoutPlayersInput, EventUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: EventCreateOrConnectWithoutPlayersInput
    upsert?: EventUpsertWithoutPlayersInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutPlayersInput, EventUpdateWithoutPlayersInput>, EventUncheckedUpdateWithoutPlayersInput>
  }

  export type ZoneCreateNestedOneWithoutActionsInput = {
    create?: XOR<ZoneCreateWithoutActionsInput, ZoneUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutActionsInput
    connect?: ZoneWhereUniqueInput
  }

  export type ZoneUpdateOneWithoutActionsNestedInput = {
    create?: XOR<ZoneCreateWithoutActionsInput, ZoneUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutActionsInput
    upsert?: ZoneUpsertWithoutActionsInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutActionsInput, ZoneUpdateWithoutActionsInput>, ZoneUncheckedUpdateWithoutActionsInput>
  }

  export type PlayerCreateNestedOneWithoutRelationshipsInput = {
    create?: XOR<PlayerCreateWithoutRelationshipsInput, PlayerUncheckedCreateWithoutRelationshipsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRelationshipsInput
    connect?: PlayerWhereUniqueInput
  }

  export type NPCCreateNestedOneWithoutPlayerRelationshipsInput = {
    create?: XOR<NPCCreateWithoutPlayerRelationshipsInput, NPCUncheckedCreateWithoutPlayerRelationshipsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutPlayerRelationshipsInput
    connect?: NPCWhereUniqueInput
  }

  export type PlayerUpdateOneRequiredWithoutRelationshipsNestedInput = {
    create?: XOR<PlayerCreateWithoutRelationshipsInput, PlayerUncheckedCreateWithoutRelationshipsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutRelationshipsInput
    upsert?: PlayerUpsertWithoutRelationshipsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutRelationshipsInput, PlayerUpdateWithoutRelationshipsInput>, PlayerUncheckedUpdateWithoutRelationshipsInput>
  }

  export type NPCUpdateOneRequiredWithoutPlayerRelationshipsNestedInput = {
    create?: XOR<NPCCreateWithoutPlayerRelationshipsInput, NPCUncheckedCreateWithoutPlayerRelationshipsInput>
    connectOrCreate?: NPCCreateOrConnectWithoutPlayerRelationshipsInput
    upsert?: NPCUpsertWithoutPlayerRelationshipsInput
    connect?: NPCWhereUniqueInput
    update?: XOR<XOR<NPCUpdateToOneWithWhereWithoutPlayerRelationshipsInput, NPCUpdateWithoutPlayerRelationshipsInput>, NPCUncheckedUpdateWithoutPlayerRelationshipsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MaskCreateWithoutCurrentPlayersInput = {
    id: string
    name: string
    alias: string
    description: string
    personality: string
    corruption?: number
    abilities: JsonNullValueInput | InputJsonValue
    dailyEffects: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskCreatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskCreateunlockRequirementsInput | string[]
    image: string
    symbol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerMaskCreateNestedManyWithoutMaskInput
  }

  export type MaskUncheckedCreateWithoutCurrentPlayersInput = {
    id: string
    name: string
    alias: string
    description: string
    personality: string
    corruption?: number
    abilities: JsonNullValueInput | InputJsonValue
    dailyEffects: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskCreatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskCreateunlockRequirementsInput | string[]
    image: string
    symbol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerMaskUncheckedCreateNestedManyWithoutMaskInput
  }

  export type MaskCreateOrConnectWithoutCurrentPlayersInput = {
    where: MaskWhereUniqueInput
    create: XOR<MaskCreateWithoutCurrentPlayersInput, MaskUncheckedCreateWithoutCurrentPlayersInput>
  }

  export type PlayerMaskCreateWithoutPlayerInput = {
    id?: string
    corruption?: number
    mask: MaskCreateNestedOneWithoutPlayersInput
  }

  export type PlayerMaskUncheckedCreateWithoutPlayerInput = {
    id?: string
    maskId: string
    corruption?: number
  }

  export type PlayerMaskCreateOrConnectWithoutPlayerInput = {
    where: PlayerMaskWhereUniqueInput
    create: XOR<PlayerMaskCreateWithoutPlayerInput, PlayerMaskUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerMaskCreateManyPlayerInputEnvelope = {
    data: PlayerMaskCreateManyPlayerInput | PlayerMaskCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerRelationshipCreateWithoutPlayerInput = {
    id?: string
    affinity?: number
    npc: NPCCreateNestedOneWithoutPlayerRelationshipsInput
  }

  export type PlayerRelationshipUncheckedCreateWithoutPlayerInput = {
    id?: string
    npcId: string
    affinity?: number
  }

  export type PlayerRelationshipCreateOrConnectWithoutPlayerInput = {
    where: PlayerRelationshipWhereUniqueInput
    create: XOR<PlayerRelationshipCreateWithoutPlayerInput, PlayerRelationshipUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerRelationshipCreateManyPlayerInputEnvelope = {
    data: PlayerRelationshipCreateManyPlayerInput | PlayerRelationshipCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerItemCreateWithoutPlayerInput = {
    id?: string
    quantity?: number
    item: ItemCreateNestedOneWithoutPlayersInput
  }

  export type PlayerItemUncheckedCreateWithoutPlayerInput = {
    id?: string
    itemId: string
    quantity?: number
  }

  export type PlayerItemCreateOrConnectWithoutPlayerInput = {
    where: PlayerItemWhereUniqueInput
    create: XOR<PlayerItemCreateWithoutPlayerInput, PlayerItemUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerItemCreateManyPlayerInputEnvelope = {
    data: PlayerItemCreateManyPlayerInput | PlayerItemCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerMinigameCreateWithoutPlayerInput = {
    id?: string
    score?: number
    completed?: boolean
    minigame: MinigameCreateNestedOneWithoutPlayerProgressInput
  }

  export type PlayerMinigameUncheckedCreateWithoutPlayerInput = {
    id?: string
    minigameId: string
    score?: number
    completed?: boolean
  }

  export type PlayerMinigameCreateOrConnectWithoutPlayerInput = {
    where: PlayerMinigameWhereUniqueInput
    create: XOR<PlayerMinigameCreateWithoutPlayerInput, PlayerMinigameUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerMinigameCreateManyPlayerInputEnvelope = {
    data: PlayerMinigameCreateManyPlayerInput | PlayerMinigameCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PlayerEventCreateWithoutPlayerInput = {
    id?: string
    choiceMade?: string | null
    completed?: boolean
    event: EventCreateNestedOneWithoutPlayersInput
  }

  export type PlayerEventUncheckedCreateWithoutPlayerInput = {
    id?: string
    eventId: string
    choiceMade?: string | null
    completed?: boolean
  }

  export type PlayerEventCreateOrConnectWithoutPlayerInput = {
    where: PlayerEventWhereUniqueInput
    create: XOR<PlayerEventCreateWithoutPlayerInput, PlayerEventUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEventCreateManyPlayerInputEnvelope = {
    data: PlayerEventCreateManyPlayerInput | PlayerEventCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type ZoneCreateWithoutPlayersInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    npcs?: NPCCreateNestedManyWithoutLocationInput
    events?: EventCreateNestedManyWithoutZoneInput
    actions?: ActionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutPlayersInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    npcs?: NPCUncheckedCreateNestedManyWithoutLocationInput
    events?: EventUncheckedCreateNestedManyWithoutZoneInput
    actions?: ActionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutPlayersInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutPlayersInput, ZoneUncheckedCreateWithoutPlayersInput>
  }

  export type MaskUpsertWithoutCurrentPlayersInput = {
    update: XOR<MaskUpdateWithoutCurrentPlayersInput, MaskUncheckedUpdateWithoutCurrentPlayersInput>
    create: XOR<MaskCreateWithoutCurrentPlayersInput, MaskUncheckedCreateWithoutCurrentPlayersInput>
    where?: MaskWhereInput
  }

  export type MaskUpdateToOneWithWhereWithoutCurrentPlayersInput = {
    where?: MaskWhereInput
    data: XOR<MaskUpdateWithoutCurrentPlayersInput, MaskUncheckedUpdateWithoutCurrentPlayersInput>
  }

  export type MaskUpdateWithoutCurrentPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    abilities?: JsonNullValueInput | InputJsonValue
    dailyEffects?: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskUpdatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskUpdateunlockRequirementsInput | string[]
    image?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerMaskUpdateManyWithoutMaskNestedInput
  }

  export type MaskUncheckedUpdateWithoutCurrentPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    abilities?: JsonNullValueInput | InputJsonValue
    dailyEffects?: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskUpdatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskUpdateunlockRequirementsInput | string[]
    image?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerMaskUncheckedUpdateManyWithoutMaskNestedInput
  }

  export type PlayerMaskUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerMaskWhereUniqueInput
    update: XOR<PlayerMaskUpdateWithoutPlayerInput, PlayerMaskUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerMaskCreateWithoutPlayerInput, PlayerMaskUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerMaskUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerMaskWhereUniqueInput
    data: XOR<PlayerMaskUpdateWithoutPlayerInput, PlayerMaskUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerMaskUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerMaskScalarWhereInput
    data: XOR<PlayerMaskUpdateManyMutationInput, PlayerMaskUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerMaskScalarWhereInput = {
    AND?: PlayerMaskScalarWhereInput | PlayerMaskScalarWhereInput[]
    OR?: PlayerMaskScalarWhereInput[]
    NOT?: PlayerMaskScalarWhereInput | PlayerMaskScalarWhereInput[]
    id?: StringFilter<"PlayerMask"> | string
    playerId?: StringFilter<"PlayerMask"> | string
    maskId?: StringFilter<"PlayerMask"> | string
    corruption?: IntFilter<"PlayerMask"> | number
  }

  export type PlayerRelationshipUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerRelationshipWhereUniqueInput
    update: XOR<PlayerRelationshipUpdateWithoutPlayerInput, PlayerRelationshipUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerRelationshipCreateWithoutPlayerInput, PlayerRelationshipUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerRelationshipUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerRelationshipWhereUniqueInput
    data: XOR<PlayerRelationshipUpdateWithoutPlayerInput, PlayerRelationshipUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerRelationshipUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerRelationshipScalarWhereInput
    data: XOR<PlayerRelationshipUpdateManyMutationInput, PlayerRelationshipUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerRelationshipScalarWhereInput = {
    AND?: PlayerRelationshipScalarWhereInput | PlayerRelationshipScalarWhereInput[]
    OR?: PlayerRelationshipScalarWhereInput[]
    NOT?: PlayerRelationshipScalarWhereInput | PlayerRelationshipScalarWhereInput[]
    id?: StringFilter<"PlayerRelationship"> | string
    playerId?: StringFilter<"PlayerRelationship"> | string
    npcId?: StringFilter<"PlayerRelationship"> | string
    affinity?: IntFilter<"PlayerRelationship"> | number
  }

  export type PlayerItemUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerItemWhereUniqueInput
    update: XOR<PlayerItemUpdateWithoutPlayerInput, PlayerItemUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerItemCreateWithoutPlayerInput, PlayerItemUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerItemUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerItemWhereUniqueInput
    data: XOR<PlayerItemUpdateWithoutPlayerInput, PlayerItemUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerItemUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerItemScalarWhereInput
    data: XOR<PlayerItemUpdateManyMutationInput, PlayerItemUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerItemScalarWhereInput = {
    AND?: PlayerItemScalarWhereInput | PlayerItemScalarWhereInput[]
    OR?: PlayerItemScalarWhereInput[]
    NOT?: PlayerItemScalarWhereInput | PlayerItemScalarWhereInput[]
    id?: StringFilter<"PlayerItem"> | string
    playerId?: StringFilter<"PlayerItem"> | string
    itemId?: StringFilter<"PlayerItem"> | string
    quantity?: IntFilter<"PlayerItem"> | number
  }

  export type PlayerMinigameUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerMinigameWhereUniqueInput
    update: XOR<PlayerMinigameUpdateWithoutPlayerInput, PlayerMinigameUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerMinigameCreateWithoutPlayerInput, PlayerMinigameUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerMinigameUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerMinigameWhereUniqueInput
    data: XOR<PlayerMinigameUpdateWithoutPlayerInput, PlayerMinigameUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerMinigameUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerMinigameScalarWhereInput
    data: XOR<PlayerMinigameUpdateManyMutationInput, PlayerMinigameUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerMinigameScalarWhereInput = {
    AND?: PlayerMinigameScalarWhereInput | PlayerMinigameScalarWhereInput[]
    OR?: PlayerMinigameScalarWhereInput[]
    NOT?: PlayerMinigameScalarWhereInput | PlayerMinigameScalarWhereInput[]
    id?: StringFilter<"PlayerMinigame"> | string
    playerId?: StringFilter<"PlayerMinigame"> | string
    minigameId?: StringFilter<"PlayerMinigame"> | string
    score?: IntFilter<"PlayerMinigame"> | number
    completed?: BoolFilter<"PlayerMinigame"> | boolean
  }

  export type PlayerEventUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PlayerEventWhereUniqueInput
    update: XOR<PlayerEventUpdateWithoutPlayerInput, PlayerEventUncheckedUpdateWithoutPlayerInput>
    create: XOR<PlayerEventCreateWithoutPlayerInput, PlayerEventUncheckedCreateWithoutPlayerInput>
  }

  export type PlayerEventUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PlayerEventWhereUniqueInput
    data: XOR<PlayerEventUpdateWithoutPlayerInput, PlayerEventUncheckedUpdateWithoutPlayerInput>
  }

  export type PlayerEventUpdateManyWithWhereWithoutPlayerInput = {
    where: PlayerEventScalarWhereInput
    data: XOR<PlayerEventUpdateManyMutationInput, PlayerEventUncheckedUpdateManyWithoutPlayerInput>
  }

  export type PlayerEventScalarWhereInput = {
    AND?: PlayerEventScalarWhereInput | PlayerEventScalarWhereInput[]
    OR?: PlayerEventScalarWhereInput[]
    NOT?: PlayerEventScalarWhereInput | PlayerEventScalarWhereInput[]
    id?: StringFilter<"PlayerEvent"> | string
    playerId?: StringFilter<"PlayerEvent"> | string
    eventId?: StringFilter<"PlayerEvent"> | string
    choiceMade?: StringNullableFilter<"PlayerEvent"> | string | null
    completed?: BoolFilter<"PlayerEvent"> | boolean
  }

  export type ZoneUpsertWithoutPlayersInput = {
    update: XOR<ZoneUpdateWithoutPlayersInput, ZoneUncheckedUpdateWithoutPlayersInput>
    create: XOR<ZoneCreateWithoutPlayersInput, ZoneUncheckedCreateWithoutPlayersInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutPlayersInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutPlayersInput, ZoneUncheckedUpdateWithoutPlayersInput>
  }

  export type ZoneUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcs?: NPCUpdateManyWithoutLocationNestedInput
    events?: EventUpdateManyWithoutZoneNestedInput
    actions?: ActionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcs?: NPCUncheckedUpdateManyWithoutLocationNestedInput
    events?: EventUncheckedUpdateManyWithoutZoneNestedInput
    actions?: ActionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type PlayerMaskCreateWithoutMaskInput = {
    id?: string
    corruption?: number
    player: PlayerCreateNestedOneWithoutMasksOwnedInput
  }

  export type PlayerMaskUncheckedCreateWithoutMaskInput = {
    id?: string
    playerId: string
    corruption?: number
  }

  export type PlayerMaskCreateOrConnectWithoutMaskInput = {
    where: PlayerMaskWhereUniqueInput
    create: XOR<PlayerMaskCreateWithoutMaskInput, PlayerMaskUncheckedCreateWithoutMaskInput>
  }

  export type PlayerMaskCreateManyMaskInputEnvelope = {
    data: PlayerMaskCreateManyMaskInput | PlayerMaskCreateManyMaskInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutCurrentMaskInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    masksOwned?: PlayerMaskCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventCreateNestedManyWithoutPlayerInput
    location?: ZoneCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutCurrentMaskInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    masksOwned?: PlayerMaskUncheckedCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemUncheckedCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameUncheckedCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCurrentMaskInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCurrentMaskInput, PlayerUncheckedCreateWithoutCurrentMaskInput>
  }

  export type PlayerCreateManyCurrentMaskInputEnvelope = {
    data: PlayerCreateManyCurrentMaskInput | PlayerCreateManyCurrentMaskInput[]
    skipDuplicates?: boolean
  }

  export type PlayerMaskUpsertWithWhereUniqueWithoutMaskInput = {
    where: PlayerMaskWhereUniqueInput
    update: XOR<PlayerMaskUpdateWithoutMaskInput, PlayerMaskUncheckedUpdateWithoutMaskInput>
    create: XOR<PlayerMaskCreateWithoutMaskInput, PlayerMaskUncheckedCreateWithoutMaskInput>
  }

  export type PlayerMaskUpdateWithWhereUniqueWithoutMaskInput = {
    where: PlayerMaskWhereUniqueInput
    data: XOR<PlayerMaskUpdateWithoutMaskInput, PlayerMaskUncheckedUpdateWithoutMaskInput>
  }

  export type PlayerMaskUpdateManyWithWhereWithoutMaskInput = {
    where: PlayerMaskScalarWhereInput
    data: XOR<PlayerMaskUpdateManyMutationInput, PlayerMaskUncheckedUpdateManyWithoutMaskInput>
  }

  export type PlayerUpsertWithWhereUniqueWithoutCurrentMaskInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutCurrentMaskInput, PlayerUncheckedUpdateWithoutCurrentMaskInput>
    create: XOR<PlayerCreateWithoutCurrentMaskInput, PlayerUncheckedCreateWithoutCurrentMaskInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutCurrentMaskInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutCurrentMaskInput, PlayerUncheckedUpdateWithoutCurrentMaskInput>
  }

  export type PlayerUpdateManyWithWhereWithoutCurrentMaskInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutCurrentMaskInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    OR?: PlayerScalarWhereInput[]
    NOT?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    id?: StringFilter<"Player"> | string
    username?: StringFilter<"Player"> | string
    avatar?: StringFilter<"Player"> | string
    grade?: IntFilter<"Player"> | number
    className?: StringFilter<"Player"> | string
    currentMaskId?: StringNullableFilter<"Player"> | string | null
    energy?: IntFilter<"Player"> | number
    mood?: StringFilter<"Player"> | string
    time?: StringFilter<"Player"> | string
    reputation?: IntFilter<"Player"> | number
    zoneId?: StringNullableFilter<"Player"> | string | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    updatedAt?: DateTimeFilter<"Player"> | Date | string
  }

  export type PlayerCreateWithoutMasksOwnedInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMask?: MaskCreateNestedOneWithoutCurrentPlayersInput
    relationships?: PlayerRelationshipCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventCreateNestedManyWithoutPlayerInput
    location?: ZoneCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutMasksOwnedInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    relationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemUncheckedCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameUncheckedCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMasksOwnedInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMasksOwnedInput, PlayerUncheckedCreateWithoutMasksOwnedInput>
  }

  export type MaskCreateWithoutPlayersInput = {
    id: string
    name: string
    alias: string
    description: string
    personality: string
    corruption?: number
    abilities: JsonNullValueInput | InputJsonValue
    dailyEffects: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskCreatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskCreateunlockRequirementsInput | string[]
    image: string
    symbol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentPlayers?: PlayerCreateNestedManyWithoutCurrentMaskInput
  }

  export type MaskUncheckedCreateWithoutPlayersInput = {
    id: string
    name: string
    alias: string
    description: string
    personality: string
    corruption?: number
    abilities: JsonNullValueInput | InputJsonValue
    dailyEffects: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskCreatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskCreateunlockRequirementsInput | string[]
    image: string
    symbol: string
    createdAt?: Date | string
    updatedAt?: Date | string
    currentPlayers?: PlayerUncheckedCreateNestedManyWithoutCurrentMaskInput
  }

  export type MaskCreateOrConnectWithoutPlayersInput = {
    where: MaskWhereUniqueInput
    create: XOR<MaskCreateWithoutPlayersInput, MaskUncheckedCreateWithoutPlayersInput>
  }

  export type PlayerUpsertWithoutMasksOwnedInput = {
    update: XOR<PlayerUpdateWithoutMasksOwnedInput, PlayerUncheckedUpdateWithoutMasksOwnedInput>
    create: XOR<PlayerCreateWithoutMasksOwnedInput, PlayerUncheckedCreateWithoutMasksOwnedInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMasksOwnedInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMasksOwnedInput, PlayerUncheckedUpdateWithoutMasksOwnedInput>
  }

  export type PlayerUpdateWithoutMasksOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMask?: MaskUpdateOneWithoutCurrentPlayersNestedInput
    relationships?: PlayerRelationshipUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUpdateManyWithoutPlayerNestedInput
    location?: ZoneUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMasksOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relationships?: PlayerRelationshipUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUncheckedUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUncheckedUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type MaskUpsertWithoutPlayersInput = {
    update: XOR<MaskUpdateWithoutPlayersInput, MaskUncheckedUpdateWithoutPlayersInput>
    create: XOR<MaskCreateWithoutPlayersInput, MaskUncheckedCreateWithoutPlayersInput>
    where?: MaskWhereInput
  }

  export type MaskUpdateToOneWithWhereWithoutPlayersInput = {
    where?: MaskWhereInput
    data: XOR<MaskUpdateWithoutPlayersInput, MaskUncheckedUpdateWithoutPlayersInput>
  }

  export type MaskUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    abilities?: JsonNullValueInput | InputJsonValue
    dailyEffects?: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskUpdatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskUpdateunlockRequirementsInput | string[]
    image?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPlayers?: PlayerUpdateManyWithoutCurrentMaskNestedInput
  }

  export type MaskUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    alias?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    personality?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    abilities?: JsonNullValueInput | InputJsonValue
    dailyEffects?: JsonNullValueInput | InputJsonValue
    corruptionTriggers?: MaskUpdatecorruptionTriggersInput | string[]
    unlockRequirements?: MaskUpdateunlockRequirementsInput | string[]
    image?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentPlayers?: PlayerUncheckedUpdateManyWithoutCurrentMaskNestedInput
  }

  export type ZoneCreateWithoutNpcsInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerCreateNestedManyWithoutLocationInput
    events?: EventCreateNestedManyWithoutZoneInput
    actions?: ActionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutNpcsInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerUncheckedCreateNestedManyWithoutLocationInput
    events?: EventUncheckedCreateNestedManyWithoutZoneInput
    actions?: ActionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutNpcsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutNpcsInput, ZoneUncheckedCreateWithoutNpcsInput>
  }

  export type PlayerRelationshipCreateWithoutNpcInput = {
    id?: string
    affinity?: number
    player: PlayerCreateNestedOneWithoutRelationshipsInput
  }

  export type PlayerRelationshipUncheckedCreateWithoutNpcInput = {
    id?: string
    playerId: string
    affinity?: number
  }

  export type PlayerRelationshipCreateOrConnectWithoutNpcInput = {
    where: PlayerRelationshipWhereUniqueInput
    create: XOR<PlayerRelationshipCreateWithoutNpcInput, PlayerRelationshipUncheckedCreateWithoutNpcInput>
  }

  export type PlayerRelationshipCreateManyNpcInputEnvelope = {
    data: PlayerRelationshipCreateManyNpcInput | PlayerRelationshipCreateManyNpcInput[]
    skipDuplicates?: boolean
  }

  export type ZoneUpsertWithoutNpcsInput = {
    update: XOR<ZoneUpdateWithoutNpcsInput, ZoneUncheckedUpdateWithoutNpcsInput>
    create: XOR<ZoneCreateWithoutNpcsInput, ZoneUncheckedCreateWithoutNpcsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutNpcsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutNpcsInput, ZoneUncheckedUpdateWithoutNpcsInput>
  }

  export type ZoneUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUpdateManyWithoutLocationNestedInput
    events?: EventUpdateManyWithoutZoneNestedInput
    actions?: ActionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutNpcsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerUncheckedUpdateManyWithoutLocationNestedInput
    events?: EventUncheckedUpdateManyWithoutZoneNestedInput
    actions?: ActionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type PlayerRelationshipUpsertWithWhereUniqueWithoutNpcInput = {
    where: PlayerRelationshipWhereUniqueInput
    update: XOR<PlayerRelationshipUpdateWithoutNpcInput, PlayerRelationshipUncheckedUpdateWithoutNpcInput>
    create: XOR<PlayerRelationshipCreateWithoutNpcInput, PlayerRelationshipUncheckedCreateWithoutNpcInput>
  }

  export type PlayerRelationshipUpdateWithWhereUniqueWithoutNpcInput = {
    where: PlayerRelationshipWhereUniqueInput
    data: XOR<PlayerRelationshipUpdateWithoutNpcInput, PlayerRelationshipUncheckedUpdateWithoutNpcInput>
  }

  export type PlayerRelationshipUpdateManyWithWhereWithoutNpcInput = {
    where: PlayerRelationshipScalarWhereInput
    data: XOR<PlayerRelationshipUpdateManyMutationInput, PlayerRelationshipUncheckedUpdateManyWithoutNpcInput>
  }

  export type NPCCreateWithoutLocationInput = {
    id: string
    name: string
    role: string
    traits?: NPCCreatetraitsInput | string[]
    personality: string
    schedule: JsonNullValueInput | InputJsonValue
    relationship?: number
    rumorScore?: number
    reactions: JsonNullValueInput | InputJsonValue
    events?: NPCCreateeventsInput | string[]
    portrait: string
    createdAt?: Date | string
    updatedAt?: Date | string
    playerRelationships?: PlayerRelationshipCreateNestedManyWithoutNpcInput
  }

  export type NPCUncheckedCreateWithoutLocationInput = {
    id: string
    name: string
    role: string
    traits?: NPCCreatetraitsInput | string[]
    personality: string
    schedule: JsonNullValueInput | InputJsonValue
    relationship?: number
    rumorScore?: number
    reactions: JsonNullValueInput | InputJsonValue
    events?: NPCCreateeventsInput | string[]
    portrait: string
    createdAt?: Date | string
    updatedAt?: Date | string
    playerRelationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutNpcInput
  }

  export type NPCCreateOrConnectWithoutLocationInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutLocationInput, NPCUncheckedCreateWithoutLocationInput>
  }

  export type NPCCreateManyLocationInputEnvelope = {
    data: NPCCreateManyLocationInput | NPCCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutLocationInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMask?: MaskCreateNestedOneWithoutCurrentPlayersInput
    masksOwned?: PlayerMaskCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutLocationInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    masksOwned?: PlayerMaskUncheckedCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemUncheckedCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameUncheckedCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutLocationInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutLocationInput, PlayerUncheckedCreateWithoutLocationInput>
  }

  export type PlayerCreateManyLocationInputEnvelope = {
    data: PlayerCreateManyLocationInput | PlayerCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutZoneInput = {
    id: string
    name: string
    triggerChance: number
    triggerZones?: EventCreatetriggerZonesInput | string[]
    maskModifiers: JsonNullValueInput | InputJsonValue
    choices: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerEventCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutZoneInput = {
    id: string
    name: string
    triggerChance: number
    triggerZones?: EventCreatetriggerZonesInput | string[]
    maskModifiers: JsonNullValueInput | InputJsonValue
    choices: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: PlayerEventUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutZoneInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutZoneInput, EventUncheckedCreateWithoutZoneInput>
  }

  export type EventCreateManyZoneInputEnvelope = {
    data: EventCreateManyZoneInput | EventCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type ActionCreateWithoutZoneInput = {
    id: string
    name: string
    preconditions: JsonNullValueInput | InputJsonValue
    timeCost: number
    effects: JsonNullValueInput | InputJsonValue
    riskLevel: string
    maskModifiers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionUncheckedCreateWithoutZoneInput = {
    id: string
    name: string
    preconditions: JsonNullValueInput | InputJsonValue
    timeCost: number
    effects: JsonNullValueInput | InputJsonValue
    riskLevel: string
    maskModifiers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionCreateOrConnectWithoutZoneInput = {
    where: ActionWhereUniqueInput
    create: XOR<ActionCreateWithoutZoneInput, ActionUncheckedCreateWithoutZoneInput>
  }

  export type ActionCreateManyZoneInputEnvelope = {
    data: ActionCreateManyZoneInput | ActionCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type NPCUpsertWithWhereUniqueWithoutLocationInput = {
    where: NPCWhereUniqueInput
    update: XOR<NPCUpdateWithoutLocationInput, NPCUncheckedUpdateWithoutLocationInput>
    create: XOR<NPCCreateWithoutLocationInput, NPCUncheckedCreateWithoutLocationInput>
  }

  export type NPCUpdateWithWhereUniqueWithoutLocationInput = {
    where: NPCWhereUniqueInput
    data: XOR<NPCUpdateWithoutLocationInput, NPCUncheckedUpdateWithoutLocationInput>
  }

  export type NPCUpdateManyWithWhereWithoutLocationInput = {
    where: NPCScalarWhereInput
    data: XOR<NPCUpdateManyMutationInput, NPCUncheckedUpdateManyWithoutLocationInput>
  }

  export type NPCScalarWhereInput = {
    AND?: NPCScalarWhereInput | NPCScalarWhereInput[]
    OR?: NPCScalarWhereInput[]
    NOT?: NPCScalarWhereInput | NPCScalarWhereInput[]
    id?: StringFilter<"NPC"> | string
    name?: StringFilter<"NPC"> | string
    role?: StringFilter<"NPC"> | string
    traits?: StringNullableListFilter<"NPC">
    personality?: StringFilter<"NPC"> | string
    schedule?: JsonFilter<"NPC">
    relationship?: IntFilter<"NPC"> | number
    rumorScore?: IntFilter<"NPC"> | number
    reactions?: JsonFilter<"NPC">
    events?: StringNullableListFilter<"NPC">
    portrait?: StringFilter<"NPC"> | string
    zoneId?: StringNullableFilter<"NPC"> | string | null
    createdAt?: DateTimeFilter<"NPC"> | Date | string
    updatedAt?: DateTimeFilter<"NPC"> | Date | string
  }

  export type PlayerUpsertWithWhereUniqueWithoutLocationInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutLocationInput, PlayerUncheckedUpdateWithoutLocationInput>
    create: XOR<PlayerCreateWithoutLocationInput, PlayerUncheckedCreateWithoutLocationInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutLocationInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutLocationInput, PlayerUncheckedUpdateWithoutLocationInput>
  }

  export type PlayerUpdateManyWithWhereWithoutLocationInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutLocationInput>
  }

  export type EventUpsertWithWhereUniqueWithoutZoneInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutZoneInput, EventUncheckedUpdateWithoutZoneInput>
    create: XOR<EventCreateWithoutZoneInput, EventUncheckedCreateWithoutZoneInput>
  }

  export type EventUpdateWithWhereUniqueWithoutZoneInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutZoneInput, EventUncheckedUpdateWithoutZoneInput>
  }

  export type EventUpdateManyWithWhereWithoutZoneInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutZoneInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    name?: StringFilter<"Event"> | string
    triggerChance?: IntFilter<"Event"> | number
    triggerZones?: StringNullableListFilter<"Event">
    maskModifiers?: JsonFilter<"Event">
    choices?: JsonFilter<"Event">
    zoneId?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type ActionUpsertWithWhereUniqueWithoutZoneInput = {
    where: ActionWhereUniqueInput
    update: XOR<ActionUpdateWithoutZoneInput, ActionUncheckedUpdateWithoutZoneInput>
    create: XOR<ActionCreateWithoutZoneInput, ActionUncheckedCreateWithoutZoneInput>
  }

  export type ActionUpdateWithWhereUniqueWithoutZoneInput = {
    where: ActionWhereUniqueInput
    data: XOR<ActionUpdateWithoutZoneInput, ActionUncheckedUpdateWithoutZoneInput>
  }

  export type ActionUpdateManyWithWhereWithoutZoneInput = {
    where: ActionScalarWhereInput
    data: XOR<ActionUpdateManyMutationInput, ActionUncheckedUpdateManyWithoutZoneInput>
  }

  export type ActionScalarWhereInput = {
    AND?: ActionScalarWhereInput | ActionScalarWhereInput[]
    OR?: ActionScalarWhereInput[]
    NOT?: ActionScalarWhereInput | ActionScalarWhereInput[]
    id?: StringFilter<"Action"> | string
    name?: StringFilter<"Action"> | string
    zoneId?: StringNullableFilter<"Action"> | string | null
    preconditions?: JsonFilter<"Action">
    timeCost?: IntFilter<"Action"> | number
    effects?: JsonFilter<"Action">
    riskLevel?: StringFilter<"Action"> | string
    maskModifiers?: JsonFilter<"Action">
    createdAt?: DateTimeFilter<"Action"> | Date | string
    updatedAt?: DateTimeFilter<"Action"> | Date | string
  }

  export type PlayerItemCreateWithoutItemInput = {
    id?: string
    quantity?: number
    player: PlayerCreateNestedOneWithoutInventoryInput
  }

  export type PlayerItemUncheckedCreateWithoutItemInput = {
    id?: string
    playerId: string
    quantity?: number
  }

  export type PlayerItemCreateOrConnectWithoutItemInput = {
    where: PlayerItemWhereUniqueInput
    create: XOR<PlayerItemCreateWithoutItemInput, PlayerItemUncheckedCreateWithoutItemInput>
  }

  export type PlayerItemCreateManyItemInputEnvelope = {
    data: PlayerItemCreateManyItemInput | PlayerItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type PlayerItemUpsertWithWhereUniqueWithoutItemInput = {
    where: PlayerItemWhereUniqueInput
    update: XOR<PlayerItemUpdateWithoutItemInput, PlayerItemUncheckedUpdateWithoutItemInput>
    create: XOR<PlayerItemCreateWithoutItemInput, PlayerItemUncheckedCreateWithoutItemInput>
  }

  export type PlayerItemUpdateWithWhereUniqueWithoutItemInput = {
    where: PlayerItemWhereUniqueInput
    data: XOR<PlayerItemUpdateWithoutItemInput, PlayerItemUncheckedUpdateWithoutItemInput>
  }

  export type PlayerItemUpdateManyWithWhereWithoutItemInput = {
    where: PlayerItemScalarWhereInput
    data: XOR<PlayerItemUpdateManyMutationInput, PlayerItemUncheckedUpdateManyWithoutItemInput>
  }

  export type PlayerCreateWithoutInventoryInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMask?: MaskCreateNestedOneWithoutCurrentPlayersInput
    masksOwned?: PlayerMaskCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventCreateNestedManyWithoutPlayerInput
    location?: ZoneCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutInventoryInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    masksOwned?: PlayerMaskUncheckedCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameUncheckedCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutInventoryInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
  }

  export type ItemCreateWithoutPlayersInput = {
    id: string
    name: string
    type: string
    description: string
    effects: JsonNullValueInput | InputJsonValue
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUncheckedCreateWithoutPlayersInput = {
    id: string
    name: string
    type: string
    description: string
    effects: JsonNullValueInput | InputJsonValue
    image: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutPlayersInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutPlayersInput, ItemUncheckedCreateWithoutPlayersInput>
  }

  export type PlayerUpsertWithoutInventoryInput = {
    update: XOR<PlayerUpdateWithoutInventoryInput, PlayerUncheckedUpdateWithoutInventoryInput>
    create: XOR<PlayerCreateWithoutInventoryInput, PlayerUncheckedCreateWithoutInventoryInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutInventoryInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutInventoryInput, PlayerUncheckedUpdateWithoutInventoryInput>
  }

  export type PlayerUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMask?: MaskUpdateOneWithoutCurrentPlayersNestedInput
    masksOwned?: PlayerMaskUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUpdateManyWithoutPlayerNestedInput
    location?: ZoneUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutInventoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masksOwned?: PlayerMaskUncheckedUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUncheckedUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUncheckedUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type ItemUpsertWithoutPlayersInput = {
    update: XOR<ItemUpdateWithoutPlayersInput, ItemUncheckedUpdateWithoutPlayersInput>
    create: XOR<ItemCreateWithoutPlayersInput, ItemUncheckedCreateWithoutPlayersInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutPlayersInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutPlayersInput, ItemUncheckedUpdateWithoutPlayersInput>
  }

  export type ItemUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    effects?: JsonNullValueInput | InputJsonValue
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    effects?: JsonNullValueInput | InputJsonValue
    image?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMinigameCreateWithoutMinigameInput = {
    id?: string
    score?: number
    completed?: boolean
    player: PlayerCreateNestedOneWithoutMinigameProgressInput
  }

  export type PlayerMinigameUncheckedCreateWithoutMinigameInput = {
    id?: string
    playerId: string
    score?: number
    completed?: boolean
  }

  export type PlayerMinigameCreateOrConnectWithoutMinigameInput = {
    where: PlayerMinigameWhereUniqueInput
    create: XOR<PlayerMinigameCreateWithoutMinigameInput, PlayerMinigameUncheckedCreateWithoutMinigameInput>
  }

  export type PlayerMinigameCreateManyMinigameInputEnvelope = {
    data: PlayerMinigameCreateManyMinigameInput | PlayerMinigameCreateManyMinigameInput[]
    skipDuplicates?: boolean
  }

  export type PlayerMinigameUpsertWithWhereUniqueWithoutMinigameInput = {
    where: PlayerMinigameWhereUniqueInput
    update: XOR<PlayerMinigameUpdateWithoutMinigameInput, PlayerMinigameUncheckedUpdateWithoutMinigameInput>
    create: XOR<PlayerMinigameCreateWithoutMinigameInput, PlayerMinigameUncheckedCreateWithoutMinigameInput>
  }

  export type PlayerMinigameUpdateWithWhereUniqueWithoutMinigameInput = {
    where: PlayerMinigameWhereUniqueInput
    data: XOR<PlayerMinigameUpdateWithoutMinigameInput, PlayerMinigameUncheckedUpdateWithoutMinigameInput>
  }

  export type PlayerMinigameUpdateManyWithWhereWithoutMinigameInput = {
    where: PlayerMinigameScalarWhereInput
    data: XOR<PlayerMinigameUpdateManyMutationInput, PlayerMinigameUncheckedUpdateManyWithoutMinigameInput>
  }

  export type PlayerCreateWithoutMinigameProgressInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMask?: MaskCreateNestedOneWithoutCurrentPlayersInput
    masksOwned?: PlayerMaskCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventCreateNestedManyWithoutPlayerInput
    location?: ZoneCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutMinigameProgressInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    masksOwned?: PlayerMaskUncheckedCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemUncheckedCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMinigameProgressInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMinigameProgressInput, PlayerUncheckedCreateWithoutMinigameProgressInput>
  }

  export type MinigameCreateWithoutPlayerProgressInput = {
    id: string
    classId: string
    name: string
    description: string
    difficulty: number
    maskModifiers: JsonNullValueInput | InputJsonValue
    rewards: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinigameUncheckedCreateWithoutPlayerProgressInput = {
    id: string
    classId: string
    name: string
    description: string
    difficulty: number
    maskModifiers: JsonNullValueInput | InputJsonValue
    rewards: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MinigameCreateOrConnectWithoutPlayerProgressInput = {
    where: MinigameWhereUniqueInput
    create: XOR<MinigameCreateWithoutPlayerProgressInput, MinigameUncheckedCreateWithoutPlayerProgressInput>
  }

  export type PlayerUpsertWithoutMinigameProgressInput = {
    update: XOR<PlayerUpdateWithoutMinigameProgressInput, PlayerUncheckedUpdateWithoutMinigameProgressInput>
    create: XOR<PlayerCreateWithoutMinigameProgressInput, PlayerUncheckedCreateWithoutMinigameProgressInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMinigameProgressInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMinigameProgressInput, PlayerUncheckedUpdateWithoutMinigameProgressInput>
  }

  export type PlayerUpdateWithoutMinigameProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMask?: MaskUpdateOneWithoutCurrentPlayersNestedInput
    masksOwned?: PlayerMaskUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUpdateManyWithoutPlayerNestedInput
    location?: ZoneUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMinigameProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masksOwned?: PlayerMaskUncheckedUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUncheckedUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type MinigameUpsertWithoutPlayerProgressInput = {
    update: XOR<MinigameUpdateWithoutPlayerProgressInput, MinigameUncheckedUpdateWithoutPlayerProgressInput>
    create: XOR<MinigameCreateWithoutPlayerProgressInput, MinigameUncheckedCreateWithoutPlayerProgressInput>
    where?: MinigameWhereInput
  }

  export type MinigameUpdateToOneWithWhereWithoutPlayerProgressInput = {
    where?: MinigameWhereInput
    data: XOR<MinigameUpdateWithoutPlayerProgressInput, MinigameUncheckedUpdateWithoutPlayerProgressInput>
  }

  export type MinigameUpdateWithoutPlayerProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    maskModifiers?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MinigameUncheckedUpdateWithoutPlayerProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: IntFieldUpdateOperationsInput | number
    maskModifiers?: JsonNullValueInput | InputJsonValue
    rewards?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateWithoutEventsInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    npcs?: NPCCreateNestedManyWithoutLocationInput
    players?: PlayerCreateNestedManyWithoutLocationInput
    actions?: ActionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutEventsInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    npcs?: NPCUncheckedCreateNestedManyWithoutLocationInput
    players?: PlayerUncheckedCreateNestedManyWithoutLocationInput
    actions?: ActionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutEventsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutEventsInput, ZoneUncheckedCreateWithoutEventsInput>
  }

  export type PlayerEventCreateWithoutEventInput = {
    id?: string
    choiceMade?: string | null
    completed?: boolean
    player: PlayerCreateNestedOneWithoutEventsCompletedInput
  }

  export type PlayerEventUncheckedCreateWithoutEventInput = {
    id?: string
    playerId: string
    choiceMade?: string | null
    completed?: boolean
  }

  export type PlayerEventCreateOrConnectWithoutEventInput = {
    where: PlayerEventWhereUniqueInput
    create: XOR<PlayerEventCreateWithoutEventInput, PlayerEventUncheckedCreateWithoutEventInput>
  }

  export type PlayerEventCreateManyEventInputEnvelope = {
    data: PlayerEventCreateManyEventInput | PlayerEventCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type ZoneUpsertWithoutEventsInput = {
    update: XOR<ZoneUpdateWithoutEventsInput, ZoneUncheckedUpdateWithoutEventsInput>
    create: XOR<ZoneCreateWithoutEventsInput, ZoneUncheckedCreateWithoutEventsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutEventsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutEventsInput, ZoneUncheckedUpdateWithoutEventsInput>
  }

  export type ZoneUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcs?: NPCUpdateManyWithoutLocationNestedInput
    players?: PlayerUpdateManyWithoutLocationNestedInput
    actions?: ActionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcs?: NPCUncheckedUpdateManyWithoutLocationNestedInput
    players?: PlayerUncheckedUpdateManyWithoutLocationNestedInput
    actions?: ActionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type PlayerEventUpsertWithWhereUniqueWithoutEventInput = {
    where: PlayerEventWhereUniqueInput
    update: XOR<PlayerEventUpdateWithoutEventInput, PlayerEventUncheckedUpdateWithoutEventInput>
    create: XOR<PlayerEventCreateWithoutEventInput, PlayerEventUncheckedCreateWithoutEventInput>
  }

  export type PlayerEventUpdateWithWhereUniqueWithoutEventInput = {
    where: PlayerEventWhereUniqueInput
    data: XOR<PlayerEventUpdateWithoutEventInput, PlayerEventUncheckedUpdateWithoutEventInput>
  }

  export type PlayerEventUpdateManyWithWhereWithoutEventInput = {
    where: PlayerEventScalarWhereInput
    data: XOR<PlayerEventUpdateManyMutationInput, PlayerEventUncheckedUpdateManyWithoutEventInput>
  }

  export type PlayerCreateWithoutEventsCompletedInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMask?: MaskCreateNestedOneWithoutCurrentPlayersInput
    masksOwned?: PlayerMaskCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameCreateNestedManyWithoutPlayerInput
    location?: ZoneCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutEventsCompletedInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    masksOwned?: PlayerMaskUncheckedCreateNestedManyWithoutPlayerInput
    relationships?: PlayerRelationshipUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemUncheckedCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutEventsCompletedInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutEventsCompletedInput, PlayerUncheckedCreateWithoutEventsCompletedInput>
  }

  export type EventCreateWithoutPlayersInput = {
    id: string
    name: string
    triggerChance: number
    triggerZones?: EventCreatetriggerZonesInput | string[]
    maskModifiers: JsonNullValueInput | InputJsonValue
    choices: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    zone?: ZoneCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutPlayersInput = {
    id: string
    name: string
    triggerChance: number
    triggerZones?: EventCreatetriggerZonesInput | string[]
    maskModifiers: JsonNullValueInput | InputJsonValue
    choices: JsonNullValueInput | InputJsonValue
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateOrConnectWithoutPlayersInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutPlayersInput, EventUncheckedCreateWithoutPlayersInput>
  }

  export type PlayerUpsertWithoutEventsCompletedInput = {
    update: XOR<PlayerUpdateWithoutEventsCompletedInput, PlayerUncheckedUpdateWithoutEventsCompletedInput>
    create: XOR<PlayerCreateWithoutEventsCompletedInput, PlayerUncheckedCreateWithoutEventsCompletedInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutEventsCompletedInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutEventsCompletedInput, PlayerUncheckedUpdateWithoutEventsCompletedInput>
  }

  export type PlayerUpdateWithoutEventsCompletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMask?: MaskUpdateOneWithoutCurrentPlayersNestedInput
    masksOwned?: PlayerMaskUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUpdateManyWithoutPlayerNestedInput
    location?: ZoneUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutEventsCompletedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masksOwned?: PlayerMaskUncheckedUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUncheckedUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type EventUpsertWithoutPlayersInput = {
    update: XOR<EventUpdateWithoutPlayersInput, EventUncheckedUpdateWithoutPlayersInput>
    create: XOR<EventCreateWithoutPlayersInput, EventUncheckedCreateWithoutPlayersInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutPlayersInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutPlayersInput, EventUncheckedUpdateWithoutPlayersInput>
  }

  export type EventUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneCreateWithoutActionsInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    npcs?: NPCCreateNestedManyWithoutLocationInput
    players?: PlayerCreateNestedManyWithoutLocationInput
    events?: EventCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutActionsInput = {
    id: string
    name: string
    type: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    npcs?: NPCUncheckedCreateNestedManyWithoutLocationInput
    players?: PlayerUncheckedCreateNestedManyWithoutLocationInput
    events?: EventUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutActionsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutActionsInput, ZoneUncheckedCreateWithoutActionsInput>
  }

  export type ZoneUpsertWithoutActionsInput = {
    update: XOR<ZoneUpdateWithoutActionsInput, ZoneUncheckedUpdateWithoutActionsInput>
    create: XOR<ZoneCreateWithoutActionsInput, ZoneUncheckedCreateWithoutActionsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutActionsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutActionsInput, ZoneUncheckedUpdateWithoutActionsInput>
  }

  export type ZoneUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcs?: NPCUpdateManyWithoutLocationNestedInput
    players?: PlayerUpdateManyWithoutLocationNestedInput
    events?: EventUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    npcs?: NPCUncheckedUpdateManyWithoutLocationNestedInput
    players?: PlayerUncheckedUpdateManyWithoutLocationNestedInput
    events?: EventUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type PlayerCreateWithoutRelationshipsInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMask?: MaskCreateNestedOneWithoutCurrentPlayersInput
    masksOwned?: PlayerMaskCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventCreateNestedManyWithoutPlayerInput
    location?: ZoneCreateNestedOneWithoutPlayersInput
  }

  export type PlayerUncheckedCreateWithoutRelationshipsInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    masksOwned?: PlayerMaskUncheckedCreateNestedManyWithoutPlayerInput
    inventory?: PlayerItemUncheckedCreateNestedManyWithoutPlayerInput
    minigameProgress?: PlayerMinigameUncheckedCreateNestedManyWithoutPlayerInput
    eventsCompleted?: PlayerEventUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutRelationshipsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutRelationshipsInput, PlayerUncheckedCreateWithoutRelationshipsInput>
  }

  export type NPCCreateWithoutPlayerRelationshipsInput = {
    id: string
    name: string
    role: string
    traits?: NPCCreatetraitsInput | string[]
    personality: string
    schedule: JsonNullValueInput | InputJsonValue
    relationship?: number
    rumorScore?: number
    reactions: JsonNullValueInput | InputJsonValue
    events?: NPCCreateeventsInput | string[]
    portrait: string
    createdAt?: Date | string
    updatedAt?: Date | string
    location?: ZoneCreateNestedOneWithoutNpcsInput
  }

  export type NPCUncheckedCreateWithoutPlayerRelationshipsInput = {
    id: string
    name: string
    role: string
    traits?: NPCCreatetraitsInput | string[]
    personality: string
    schedule: JsonNullValueInput | InputJsonValue
    relationship?: number
    rumorScore?: number
    reactions: JsonNullValueInput | InputJsonValue
    events?: NPCCreateeventsInput | string[]
    portrait: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NPCCreateOrConnectWithoutPlayerRelationshipsInput = {
    where: NPCWhereUniqueInput
    create: XOR<NPCCreateWithoutPlayerRelationshipsInput, NPCUncheckedCreateWithoutPlayerRelationshipsInput>
  }

  export type PlayerUpsertWithoutRelationshipsInput = {
    update: XOR<PlayerUpdateWithoutRelationshipsInput, PlayerUncheckedUpdateWithoutRelationshipsInput>
    create: XOR<PlayerCreateWithoutRelationshipsInput, PlayerUncheckedCreateWithoutRelationshipsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutRelationshipsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutRelationshipsInput, PlayerUncheckedUpdateWithoutRelationshipsInput>
  }

  export type PlayerUpdateWithoutRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMask?: MaskUpdateOneWithoutCurrentPlayersNestedInput
    masksOwned?: PlayerMaskUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUpdateManyWithoutPlayerNestedInput
    location?: ZoneUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masksOwned?: PlayerMaskUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUncheckedUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUncheckedUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type NPCUpsertWithoutPlayerRelationshipsInput = {
    update: XOR<NPCUpdateWithoutPlayerRelationshipsInput, NPCUncheckedUpdateWithoutPlayerRelationshipsInput>
    create: XOR<NPCCreateWithoutPlayerRelationshipsInput, NPCUncheckedCreateWithoutPlayerRelationshipsInput>
    where?: NPCWhereInput
  }

  export type NPCUpdateToOneWithWhereWithoutPlayerRelationshipsInput = {
    where?: NPCWhereInput
    data: XOR<NPCUpdateWithoutPlayerRelationshipsInput, NPCUncheckedUpdateWithoutPlayerRelationshipsInput>
  }

  export type NPCUpdateWithoutPlayerRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: ZoneUpdateOneWithoutNpcsNestedInput
  }

  export type NPCUncheckedUpdateWithoutPlayerRelationshipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerMaskCreateManyPlayerInput = {
    id?: string
    maskId: string
    corruption?: number
  }

  export type PlayerRelationshipCreateManyPlayerInput = {
    id?: string
    npcId: string
    affinity?: number
  }

  export type PlayerItemCreateManyPlayerInput = {
    id?: string
    itemId: string
    quantity?: number
  }

  export type PlayerMinigameCreateManyPlayerInput = {
    id?: string
    minigameId: string
    score?: number
    completed?: boolean
  }

  export type PlayerEventCreateManyPlayerInput = {
    id?: string
    eventId: string
    choiceMade?: string | null
    completed?: boolean
  }

  export type PlayerMaskUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    mask?: MaskUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerMaskUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    maskId?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerMaskUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    maskId?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerRelationshipUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
    npc?: NPCUpdateOneRequiredWithoutPlayerRelationshipsNestedInput
  }

  export type PlayerRelationshipUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerRelationshipUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    npcId?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerItemUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    item?: ItemUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerItemUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerItemUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerMinigameUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    minigame?: MinigameUpdateOneRequiredWithoutPlayerProgressNestedInput
  }

  export type PlayerMinigameUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    minigameId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerMinigameUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    minigameId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEventUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    event?: EventUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type PlayerEventUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEventUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerMaskCreateManyMaskInput = {
    id?: string
    playerId: string
    corruption?: number
  }

  export type PlayerCreateManyCurrentMaskInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerMaskUpdateWithoutMaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutMasksOwnedNestedInput
  }

  export type PlayerMaskUncheckedUpdateWithoutMaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerMaskUncheckedUpdateManyWithoutMaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    corruption?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerUpdateWithoutCurrentMaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masksOwned?: PlayerMaskUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUpdateManyWithoutPlayerNestedInput
    location?: ZoneUpdateOneWithoutPlayersNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCurrentMaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masksOwned?: PlayerMaskUncheckedUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUncheckedUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUncheckedUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutCurrentMaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerRelationshipCreateManyNpcInput = {
    id?: string
    playerId: string
    affinity?: number
  }

  export type PlayerRelationshipUpdateWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutRelationshipsNestedInput
  }

  export type PlayerRelationshipUncheckedUpdateWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerRelationshipUncheckedUpdateManyWithoutNpcInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    affinity?: IntFieldUpdateOperationsInput | number
  }

  export type NPCCreateManyLocationInput = {
    id: string
    name: string
    role: string
    traits?: NPCCreatetraitsInput | string[]
    personality: string
    schedule: JsonNullValueInput | InputJsonValue
    relationship?: number
    rumorScore?: number
    reactions: JsonNullValueInput | InputJsonValue
    events?: NPCCreateeventsInput | string[]
    portrait: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlayerCreateManyLocationInput = {
    id?: string
    username: string
    avatar: string
    grade: number
    className: string
    currentMaskId?: string | null
    energy?: number
    mood?: string
    time?: string
    reputation?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventCreateManyZoneInput = {
    id: string
    name: string
    triggerChance: number
    triggerZones?: EventCreatetriggerZonesInput | string[]
    maskModifiers: JsonNullValueInput | InputJsonValue
    choices: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionCreateManyZoneInput = {
    id: string
    name: string
    preconditions: JsonNullValueInput | InputJsonValue
    timeCost: number
    effects: JsonNullValueInput | InputJsonValue
    riskLevel: string
    maskModifiers: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NPCUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerRelationships?: PlayerRelationshipUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    playerRelationships?: PlayerRelationshipUncheckedUpdateManyWithoutNpcNestedInput
  }

  export type NPCUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    traits?: NPCUpdatetraitsInput | string[]
    personality?: StringFieldUpdateOperationsInput | string
    schedule?: JsonNullValueInput | InputJsonValue
    relationship?: IntFieldUpdateOperationsInput | number
    rumorScore?: IntFieldUpdateOperationsInput | number
    reactions?: JsonNullValueInput | InputJsonValue
    events?: NPCUpdateeventsInput | string[]
    portrait?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMask?: MaskUpdateOneWithoutCurrentPlayersNestedInput
    masksOwned?: PlayerMaskUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masksOwned?: PlayerMaskUncheckedUpdateManyWithoutPlayerNestedInput
    relationships?: PlayerRelationshipUncheckedUpdateManyWithoutPlayerNestedInput
    inventory?: PlayerItemUncheckedUpdateManyWithoutPlayerNestedInput
    minigameProgress?: PlayerMinigameUncheckedUpdateManyWithoutPlayerNestedInput
    eventsCompleted?: PlayerEventUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    grade?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    currentMaskId?: NullableStringFieldUpdateOperationsInput | string | null
    energy?: IntFieldUpdateOperationsInput | number
    mood?: StringFieldUpdateOperationsInput | string
    time?: StringFieldUpdateOperationsInput | string
    reputation?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerEventUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: PlayerEventUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    triggerChance?: IntFieldUpdateOperationsInput | number
    triggerZones?: EventUpdatetriggerZonesInput | string[]
    maskModifiers?: JsonNullValueInput | InputJsonValue
    choices?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    preconditions?: JsonNullValueInput | InputJsonValue
    timeCost?: IntFieldUpdateOperationsInput | number
    effects?: JsonNullValueInput | InputJsonValue
    riskLevel?: StringFieldUpdateOperationsInput | string
    maskModifiers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    preconditions?: JsonNullValueInput | InputJsonValue
    timeCost?: IntFieldUpdateOperationsInput | number
    effects?: JsonNullValueInput | InputJsonValue
    riskLevel?: StringFieldUpdateOperationsInput | string
    maskModifiers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    preconditions?: JsonNullValueInput | InputJsonValue
    timeCost?: IntFieldUpdateOperationsInput | number
    effects?: JsonNullValueInput | InputJsonValue
    riskLevel?: StringFieldUpdateOperationsInput | string
    maskModifiers?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerItemCreateManyItemInput = {
    id?: string
    playerId: string
    quantity?: number
  }

  export type PlayerItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutInventoryNestedInput
  }

  export type PlayerItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PlayerMinigameCreateManyMinigameInput = {
    id?: string
    playerId: string
    score?: number
    completed?: boolean
  }

  export type PlayerMinigameUpdateWithoutMinigameInput = {
    id?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneRequiredWithoutMinigameProgressNestedInput
  }

  export type PlayerMinigameUncheckedUpdateWithoutMinigameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerMinigameUncheckedUpdateManyWithoutMinigameInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    score?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEventCreateManyEventInput = {
    id?: string
    playerId: string
    choiceMade?: string | null
    completed?: boolean
  }

  export type PlayerEventUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    player?: PlayerUpdateOneRequiredWithoutEventsCompletedNestedInput
  }

  export type PlayerEventUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlayerEventUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    choiceMade?: NullableStringFieldUpdateOperationsInput | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PlayerCountOutputTypeDefaultArgs instead
     */
    export type PlayerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaskCountOutputTypeDefaultArgs instead
     */
    export type MaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NPCCountOutputTypeDefaultArgs instead
     */
    export type NPCCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NPCCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneCountOutputTypeDefaultArgs instead
     */
    export type ZoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCountOutputTypeDefaultArgs instead
     */
    export type ItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MinigameCountOutputTypeDefaultArgs instead
     */
    export type MinigameCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MinigameCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerDefaultArgs instead
     */
    export type PlayerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaskDefaultArgs instead
     */
    export type MaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerMaskDefaultArgs instead
     */
    export type PlayerMaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerMaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NPCDefaultArgs instead
     */
    export type NPCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NPCDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneDefaultArgs instead
     */
    export type ZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerItemDefaultArgs instead
     */
    export type PlayerItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MinigameDefaultArgs instead
     */
    export type MinigameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MinigameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerMinigameDefaultArgs instead
     */
    export type PlayerMinigameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerMinigameDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerEventDefaultArgs instead
     */
    export type PlayerEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActionDefaultArgs instead
     */
    export type ActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlayerRelationshipDefaultArgs instead
     */
    export type PlayerRelationshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlayerRelationshipDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}